<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ESP32 TFT UI Designer</title>
</head>
<body style="margin:0">

<div style="display:flex;height:100vh;font-family:Arial;background:#222;color:#fff">

<!-- SOL PANEL -->
<div style="width:460px;padding:10px">
  <div id="canvas" style="
    width:320px;height:240px;
    background:#000;
    border:3px solid #555;
    position:relative;
    margin-bottom:10px"></div>

  <!-- Canvas BG -->
  Canvas BG: <input id="canvas_bg" type="color" value="#000000"><br><br>

  <!-- Add elements -->
  <button onclick="addLabel()">Add Label</button>
  <button onclick="addButton()">Add Button</button>
  <button onclick="addLine()">Add Line</button>
  <br><br>

  <!-- WebSerial -->
  <button onclick="connectSerial()">ğŸ”Œ Connect ESP32</button>
  <button onclick="disconnectSerial()">âŒ Disconnect</button>
  <button onclick="sendSerial()">ğŸš€ Send to ESP32</button>

  <!-- Arduino code output -->
  <textarea id="code" style="width:100%;height:160px;margin-top:10px"></textarea>
</div>

<!-- PROPERTIES + SERIAL -->
<div style="flex:1;padding:10px">
  <h3>Properties</h3>

  <div id="uiProps">
    Text <input id="p_text"><br>
    TX <input id="p_tx"><br>
    Font
    <select id="p_font">
      <option value="0">FreeSans9pt</option>
      <option value="1" selected>FreeSans12pt</option>
      <option value="2">FreeSans18pt</option>
      <option value="3">FreeSansBold</option>
    </select><br>
    Width <input id="p_w" type="number"><br>
    Height <input id="p_h" type="number"><br>
    BG <input id="p_bg" type="color"><br>
    FG <input id="p_fg" type="color"><br>
  </div>

  <div id="lineProps" style="display:none">
    Length <input id="p_len" type="number"><br>
    Direction
    <select id="p_dir">
      <option value="h">Horizontal</option>
      <option value="v">Vertical</option>
    </select><br>
    Thickness <input id="p_th" type="number"><br>
    Color <input id="p_lc" type="color"><br>
  </div>

  <br>
  <button onclick="del()">ğŸ—‘ Delete</button>

  <h3 style="margin-top:20px">Serial Monitor (RX)</h3>
  <textarea id="rx"
    style="width:100%;height:180px;
    background:#111;color:#0f0;
    font-family:monospace"></textarea>
</div>
</div>

<script>
/* ---------- STATE ---------- */
const canvas = document.getElementById("canvas");
const codeBox = document.getElementById("code");
const rxBox = document.getElementById("rx");
const canvasBgPicker = document.getElementById("canvas_bg");
let items=[], sel=null;

/* ---------- SERIAL ---------- */
let port, writer, reader;
let keepReading = false;

/* ---------- HELPERS ---------- */
function rgb(c){
  let ctx=document.createElement("canvas").getContext("2d");
  ctx.fillStyle=c; return ctx.fillStyle;
}

/* ---------- DRAG ---------- */
function drag(el){
  let ox,oy;
  el.onmousedown=e=>{
    sel=el; loadProps();
    ox=e.offsetX; oy=e.offsetY;
    document.onmousemove=ev=>{
      el.style.left=ev.pageX-canvas.offsetLeft-ox+"px";
      el.style.top =ev.pageY-canvas.offsetTop -oy+"px";
      gen();
    }
    document.onmouseup=()=>document.onmousemove=null;
  }
}

/* ---------- ADD ELEMENTS ---------- */
function baseEl(style){
  let e=document.createElement("div");
  e.style=style;
  e.style.position="absolute";
  e.style.border="2px dashed #aaa";
  drag(e);
  canvas.appendChild(e);
  items.push(e);
  return e;
}

function addLabel(){
  let e=baseEl(`
    left:10px;top:10px;width:160px;height:48px;
    background:black;color:white;
    display:flex;align-items:center;justify-content:center;
    border-radius:8px`);
  e.textContent="LABEL";
  e.dataset.type="label";
  e.dataset.font=1;
  e.dataset.tx="CMD";
  gen();
}

function addButton(){
  let e=baseEl(`
    left:10px;top:70px;width:160px;height:48px;
    background:black;color:white;
    display:flex;align-items:center;justify-content:center;
    border-radius:8px`);
  e.textContent="BUTTON";
  e.dataset.type="button";
  e.dataset.font=1;
  e.dataset.tx="CMD";
  gen();
}

function addLine(){
  let e=baseEl(`
    left:20px;top:150px;width:100px;height:3px;
    background:yellow;border:none`);
  e.dataset.type="line";
  e.dataset.dir="h";
  gen();
}

/* ---------- PROPS ---------- */
function loadProps(){
  if(!sel) return;
  uiProps.style.display=sel.dataset.type=="line"?"none":"block";
  lineProps.style.display=sel.dataset.type=="line"?"block":"none";

  if(sel.dataset.type!="line"){
    p_text.value=sel.textContent;
    p_tx.value=sel.dataset.tx;
    p_font.value=sel.dataset.font;
    p_w.value=sel.offsetWidth;
    p_h.value=sel.offsetHeight;
    p_bg.value=rgb(sel.style.backgroundColor);
    p_fg.value=rgb(sel.style.color);
  }else{
    p_len.value=sel.dataset.dir=="h"?sel.offsetWidth:sel.offsetHeight;
    p_th.value=sel.dataset.dir=="h"?sel.offsetHeight:sel.offsetWidth;
    p_dir.value=sel.dataset.dir;
    p_lc.value=rgb(sel.style.backgroundColor);
  }
}

function apply(){
  if(!sel) return;
  if(sel.dataset.type!="line"){
    sel.textContent=p_text.value;
    sel.dataset.tx=p_tx.value;
    sel.dataset.font=p_font.value;
    sel.style.width=p_w.value+"px";
    sel.style.height=p_h.value+"px";
    sel.style.background=p_bg.value;
    sel.style.color=p_fg.value;
  }else{
    sel.dataset.dir=p_dir.value;
    if(p_dir.value=="h"){
      sel.style.width=p_len.value+"px";
      sel.style.height=p_th.value+"px";
    }else{
      sel.style.height=p_len.value+"px";
      sel.style.width=p_th.value+"px";
    }
    sel.style.background=p_lc.value;
  }
  gen();
}

["p_text","p_tx","p_font","p_w","p_h","p_bg","p_fg","p_len","p_dir","p_th","p_lc"]
.forEach(id=>document.getElementById(id).oninput=apply);

function del(){
  if(!sel) return;
  canvas.removeChild(sel);
  items=items.filter(i=>i!=sel);
  sel=null;
  gen();
}

/* ---------- CANVAS BG ---------- */
canvasBgPicker.oninput = () => {
  canvas.style.backgroundColor = canvasBgPicker.value;
  gen();
}

/* ---------- CODE GEN ---------- */
function gen(){
  let bg=rgb(canvas.style.backgroundColor).slice(1).toUpperCase();
  let out=[`clear(0x${bg})`];

  items.forEach(e=>{
    let x=parseInt(e.style.left),
        y=parseInt(e.style.top),
        w=e.offsetWidth,
        h=e.offsetHeight;

    let bgc=rgb(e.style.backgroundColor).slice(1).toUpperCase();
    let fgc=rgb(e.style.color||"#ffffff").slice(1).toUpperCase();

    if(e.dataset.type=="label")
      out.push(`label(${x},${y},${w},${h},0x${bgc},0x${fgc},${e.textContent},${e.dataset.font})`);

    if(e.dataset.type=="button")
      out.push(`button(${x},${y},${w},${h},0x${bgc},0x${fgc},${e.textContent},${e.dataset.tx},${e.dataset.font})`);

    if(e.dataset.type=="line"){
      if(e.dataset.dir=="h")
        out.push(`line(${x},${y},${x+w},${y},0x${bgc},${h})`);
      else
        out.push(`line(${x},${y},${x},${y+h},0x${bgc},${w})`);
    }
  });

  codeBox.value=out.join("\n");
}

/* ---------- WEB SERIAL ---------- */
async function connectSerial(){
  try{
    port = await navigator.serial.requestPort();
    await port.open({ baudRate:115200 });

    writer = port.writable.getWriter();
    reader = port.readable.getReader();
    keepReading = true;

    readLoop();
    alert("ESP32 Connected");
  }catch(e){ alert(e); }
}

async function disconnectSerial(){
  try {
    keepReading = false;

    if(reader){
      await reader.cancel();
      reader.releaseLock();
      reader = null;
    }

    if(writer){
      writer.releaseLock();
      writer = null;
    }

    if(port){
      await port.close();
      port = null;
    }

    alert("ESP32 Disconnected!");
  } catch(e){
    alert("Error disconnecting: " + e);
  }
}

async function readLoop(){
  const dec = new TextDecoder();
  let buffer="";

  while(keepReading){
    const { value, done } = await reader.read();
    if(done) break;
    buffer += dec.decode(value);

    let lines = buffer.split("\n");
    buffer = lines.pop();

    lines.forEach(l=>{
      rxBox.value += l.trim() + "\n";
      rxBox.scrollTop = rxBox.scrollHeight;
    });
  }
}

async function sendSerial(){
  if(!writer){ alert("Not connected"); return; }
  const enc = new TextEncoder();
  for(let l of codeBox.value.split("\n")){
    await writer.write(enc.encode(l + "\n"));
    await new Promise(r=>setTimeout(r,50));
  }
}
</script>
</body>
</html>
