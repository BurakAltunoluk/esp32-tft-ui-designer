<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ESP32 TFT UI Designer</title>
<style>
  :root{
    --bg0:#0b1020;
    --bg1:#0f1730;
    --bg2:#121c39;
    --card:#0f1a33cc;
    --card2:#0b1328cc;
    --stroke:#243257;
    --stroke2:#2e3c69;
    --text:#e7ecff;
    --muted:#aab4da;
    --accent:#7c5cff;
    --accent2:#25d8ff;
    --good:#31d0aa;
    --warn:#ffcc66;
    --danger:#ff5c7a;
    --shadow: 0 12px 40px rgba(0,0,0,.35);
    --radius:16px;
    --radius2:12px;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
    --dockH: 240px; /* bottom dock height */
  }

  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family:var(--sans);
    color:var(--text);
    background:
      radial-gradient(1200px 800px at 20% -10%, rgba(124,92,255,.35), transparent 55%),
      radial-gradient(1000px 700px at 100% 10%, rgba(37,216,255,.22), transparent 55%),
      radial-gradient(900px 600px at 40% 120%, rgba(49,208,170,.14), transparent 55%),
      linear-gradient(180deg, var(--bg0), var(--bg1) 40%, var(--bg2));
    overflow:hidden;
  }

  /* App layout: top workspace + bottom dock */
  .app{
    height:100vh;
    display:flex;
    flex-direction:column;
    gap:12px;
    padding:14px;
  }

  .top{
    flex:1;
    min-height:0; /* important to allow internal scrolling */
    display:grid;
    grid-template-columns: 460px 1fr;
    gap:12px;
  }

  .panel{
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.08);
    border-color: rgba(36,50,87,.9);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    backdrop-filter: blur(8px);
    overflow:hidden;
    min-height:0;
  }

  .panel .hdr{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:12px 14px;
    border-bottom:1px solid rgba(255,255,255,.06);
    background: linear-gradient(180deg, rgba(255,255,255,.05), transparent);
  }

  .panel .hdr .title{
    display:flex;
    align-items:center;
    gap:10px;
    font-weight:700;
    letter-spacing:.2px;
  }

  .badge{
    font-size:12px;
    padding:4px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.10);
    color: var(--muted);
    background: rgba(0,0,0,.20);
  }

  .body{
    padding:12px 14px;
    overflow:auto;
    height:100%;
    min-height:0;
  }

  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .row + .row{ margin-top:10px; }

  label.small{
    font-size:12px;
    color:var(--muted);
    display:block;
    margin-bottom:6px;
  }

  .field{
    display:flex;
    flex-direction:column;
    gap:6px;
    min-width: 160px;
  }

  select, input[type="number"], input[type="text"]{
    width:100%;
    padding:10px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    border-color: rgba(36,50,87,.95);
    background: rgba(0,0,0,.22);
    color: var(--text);
    outline:none;
  }
  input[type="color"]{
    width:46px;
    height:40px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    border-color: rgba(36,50,87,.95);
    background: rgba(0,0,0,.22);
    padding:4px;
  }

  select:focus, input:focus{
    border-color: rgba(124,92,255,.9);
    box-shadow: 0 0 0 3px rgba(124,92,255,.20);
  }

  .btns{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }

  .btn{
    cursor:pointer;
    user-select:none;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    border-color: rgba(46,60,105,.95);
    background: rgba(0,0,0,.22);
    color: var(--text);
    padding:10px 12px;
    font-weight:600;
    display:inline-flex;
    align-items:center;
    gap:8px;
    transition: transform .06s ease, background .15s ease, border-color .15s ease;
  }
  .btn:hover{
    background: rgba(255,255,255,.06);
    border-color: rgba(124,92,255,.55);
  }
  .btn:active{ transform: translateY(1px); }

  .btn.primary{
    background: linear-gradient(135deg, rgba(124,92,255,.25), rgba(37,216,255,.10));
    border-color: rgba(124,92,255,.65);
  }
  .btn.good{
    background: linear-gradient(135deg, rgba(49,208,170,.22), rgba(37,216,255,.08));
    border-color: rgba(49,208,170,.55);
  }
  .btn.danger{
    background: linear-gradient(135deg, rgba(255,92,122,.18), rgba(124,92,255,.10));
    border-color: rgba(255,92,122,.55);
  }
  .btn.ghost{
    background: rgba(0,0,0,.16);
  }

  .hint{
    margin-top:10px;
    font-size:12px;
    color: var(--muted);
    line-height:1.4;
  }

  /* Canvas area */
  .canvasWrap{
    display:flex;
    gap:12px;
    align-items:flex-start;
    flex-wrap:wrap;
  }

  #canvas{
    background:#000;
    border:2px solid rgba(255,255,255,.08);
    border-color: rgba(46,60,105,.95);
    border-radius: 18px;
    position:relative;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.04), 0 12px 30px rgba(0,0,0,.35);
    overflow:hidden;
  }

  /* Bottom dock (code + serial) */
  .dock{
    height: var(--dockH);
    min-height: 180px;
    max-height: 40vh;
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
  }
  .dock .panel{ min-height:0; }

  textarea{
    width:100%;
    height:100%;
    resize:none;
    padding:12px 12px;
    border-radius: 14px;
    border:1px solid rgba(255,255,255,.10);
    border-color: rgba(36,50,87,.95);
    background: rgba(0,0,0,.30);
    color: var(--text);
    outline:none;
    font-family: var(--mono);
    font-size: 12px;
    line-height: 1.35;
  }
  textarea:focus{
    border-color: rgba(37,216,255,.75);
    box-shadow: 0 0 0 3px rgba(37,216,255,.18);
  }

  .monoTag{
    font-family: var(--mono);
    font-size: 12px;
    color: rgba(231,236,255,.86);
  }

  /* Make the right panel scroll if needed without covering dock */
  .panel .body{ max-height: 100%; }
</style>
</head>

<body>
<div class="app">

  <!-- TOP WORKSPACE -->
  <div class="top">

    <!-- LEFT -->
    <div class="panel">
      <div class="hdr">
        <div class="title">üéõÔ∏è Designer <span class="badge">Drag & Drop</span></div>
        <div class="badge">ESP32 TFT</div>
      </div>

      <div class="body">
        <div class="row">
          <div class="field" style="min-width:260px;">
            <label class="small">Orientation</label>
            <select id="orientation">
              <option value="landscape" selected>Landscape (320x240)</option>
              <option value="portrait">Portrait (240x320)</option>
            </select>
          </div>

          <div class="field" style="min-width:140px;">
            <label class="small">Canvas BG</label>
            <input id="canvas_bg" type="color" value="#000000">
          </div>
        </div>

        <div class="row">
          <div class="canvasWrap">
            <div id="canvas" style="width:320px;height:240px;"></div>

            <div style="display:flex;flex-direction:column;gap:10px;min-width:160px;">
              <div class="btns">
                <button class="btn ghost" onclick="addLabel()">‚ûï Label</button>
                <button class="btn ghost" onclick="addButton()">‚ûï Button</button>
                <button class="btn ghost" onclick="addLine()">‚ûï Line</button>
              </div>

              <div class="btns">
                <button class="btn good" onclick="connectSerial()">üîå Connect</button>
                <button class="btn danger" onclick="disconnectSerial()">‚ùå Disconnect</button>
                <button class="btn primary" onclick="sendSerial()">üöÄ Send</button>
              </div>

              <div class="hint">
                üí° ƒ∞pucu: Element se√ßmek i√ßin tƒ±kla, s√ºr√ºklemek i√ßin basƒ±lƒ± tutup ta≈üƒ±.<br>
                Alt paneldeki <span class="monoTag">CODE</span> ve <span class="monoTag">RX</span> alanlarƒ± sabit, hi√ßbir zaman √ºst√ºne binmez.
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>

    <!-- RIGHT -->
    <div class="panel">
      <div class="hdr">
        <div class="title">üß© Properties <span class="badge">Selected</span></div>
        <div class="badge">Live Update</div>
      </div>

      <div class="body">
        <div id="uiProps">
          <div class="row">
            <div class="field" style="min-width:260px;flex:1;">
              <label class="small">Text</label>
              <input id="p_text" type="text" placeholder="LABEL">
            </div>
            <div class="field" style="min-width:220px;flex:1;">
              <label class="small">TX</label>
              <input id="p_tx" type="text" placeholder="CMD">
            </div>
          </div>

          <div class="row">
            <div class="field" style="min-width:260px;flex:1;">
              <label class="small">Font</label>
              <select id="p_font">
                <option value="0">FreeSans9pt</option>
                <option value="1" selected>FreeSans12pt</option>
                <option value="2">FreeSans18pt</option>
                <option value="3">FreeSansBold</option>
                <option value="4">FreeMonoOblique24pt</option>
                <option value="5">FreeSans24pt</option>
                <option value="6">FreeSansOblique12pt</option>
                <option value="7">FreeSerifBold24pt</option>
                <option value="8">TomThumb</option>
                <option value="9">Tiny3x3a2pt</option>
                <option value="10">Picopixel</option>
                <option value="11">Org_01</option>
              </select>
            </div>
          </div>

          <div class="row">
            <div class="field">
              <label class="small">Width</label>
              <input id="p_w" type="number" min="1" step="1">
            </div>
            <div class="field">
              <label class="small">Height</label>
              <input id="p_h" type="number" min="1" step="1">
            </div>
            <div class="field">
              <label class="small">BG</label>
              <input id="p_bg" type="color" value="#000000">
            </div>
            <div class="field">
              <label class="small">FG</label>
              <input id="p_fg" type="color" value="#ffffff">
            </div>
          </div>
        </div>

        <div id="lineProps" style="display:none">
          <div class="row">
            <div class="field">
              <label class="small">Length</label>
              <input id="p_len" type="number" min="1" step="1">
            </div>
            <div class="field">
              <label class="small">Direction</label>
              <select id="p_dir">
                <option value="h">Horizontal</option>
                <option value="v">Vertical</option>
              </select>
            </div>
            <div class="field">
              <label class="small">Thickness</label>
              <input id="p_th" type="number" min="1" step="1">
            </div>
            <div class="field">
              <label class="small">Color</label>
              <input id="p_lc" type="color" value="#ffff00">
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:14px;">
          <button class="btn danger" onclick="del()">üóë Delete Selected</button>
        </div>

        <div class="hint">
          Not: Line elementleri rotation sonrasƒ± kaybolmasƒ±n istiyorsan ESP32 tarafƒ±nda line‚Äôlarƒ± da element listesinde saklamak gerekir (istersen onu da ekleriz).
        </div>
      </div>
    </div>

  </div>

  <!-- BOTTOM DOCK: CODE + SERIAL RX -->
  <div class="dock">
    <div class="panel">
      <div class="hdr">
        <div class="title">üìÑ Code Output <span class="badge">TX ‚Üí ESP32</span></div>
        <div class="badge monoTag">CODE</div>
      </div>
      <div class="body" style="padding:10px;">
        <textarea id="code" spellcheck="false"></textarea>
      </div>
    </div>

    <div class="panel">
      <div class="hdr">
        <div class="title">üñ•Ô∏è Serial Monitor <span class="badge">RX</span></div>
        <div class="badge monoTag">RX</div>
      </div>
      <div class="body" style="padding:10px;">
        <textarea id="rx" spellcheck="false"></textarea>
      </div>
    </div>
  </div>

</div>

<script>
/* ---------- STATE ---------- */
const canvas = document.getElementById("canvas");
const codeBox = document.getElementById("code");
const rxBox = document.getElementById("rx");
const canvasBgPicker = document.getElementById("canvas_bg");
const orientSel = document.getElementById("orientation");

const uiProps = document.getElementById("uiProps");
const lineProps = document.getElementById("lineProps");

const p_text = document.getElementById("p_text");
const p_tx   = document.getElementById("p_tx");
const p_font = document.getElementById("p_font");
const p_w    = document.getElementById("p_w");
const p_h    = document.getElementById("p_h");
const p_bg   = document.getElementById("p_bg");
const p_fg   = document.getElementById("p_fg");

const p_len  = document.getElementById("p_len");
const p_dir  = document.getElementById("p_dir");
const p_th   = document.getElementById("p_th");
const p_lc   = document.getElementById("p_lc");

let items = [], sel = null;
let loadingProps = false;

/* ---------- COLOR HELPERS (ALWAYS RETURN #RRGGBB) ---------- */
function toHex2(n){ return n.toString(16).padStart(2, "0"); }
function colorToHex(c){
  const ctx = document.createElement("canvas").getContext("2d");
  ctx.fillStyle = "#000";
  ctx.fillStyle = c || "#000";
  const s = ctx.fillStyle;

  if (s.startsWith("#")) {
    if (s.length === 4) return "#" + s[1]+s[1] + s[2]+s[2] + s[3]+s[3];
    return s.slice(0, 7);
  }
  const m = s.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
  if (m) {
    const r = Math.max(0, Math.min(255, parseInt(m[1],10)));
    const g = Math.max(0, Math.min(255, parseInt(m[2],10)));
    const b = Math.max(0, Math.min(255, parseInt(m[3],10)));
    return "#" + toHex2(r) + toHex2(g) + toHex2(b);
  }
  return "#000000";
}
function hexTo0x(hex){
  return "0x" + (hex || "#000000").replace("#","").toUpperCase();
}

/* ---------- ORIENTATION ---------- */
orientSel.onchange = ()=>{
  if(orientSel.value === "portrait"){
    canvas.style.width = "240px";
    canvas.style.height = "320px";
  }else{
    canvas.style.width = "320px";
    canvas.style.height = "240px";
  }
  gen();
};

/* ---------- SERIAL ---------- */
let port, writer, reader, keepReading = false;

/* ---------- DRAG (STABLE) ---------- */
function drag(el){
  let startX, startY, startLeft, startTop;

  el.onmousedown = (e) => {
    e.preventDefault();
    e.stopPropagation();

    sel = el;
    loadProps();

    const elRect = el.getBoundingClientRect();
    const cRect  = canvas.getBoundingClientRect();

    startX = e.clientX;
    startY = e.clientY;
    startLeft = elRect.left - cRect.left;
    startTop  = elRect.top  - cRect.top;

    document.onmousemove = (ev) => {
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      el.style.left = Math.round(startLeft + dx) + "px";
      el.style.top  = Math.round(startTop  + dy) + "px";
      gen();
    };

    document.onmouseup = () => {
      document.onmousemove = null;
      document.onmouseup = null;
    };
  };
}

/* ---------- ADD ---------- */
function baseEl(style){
  let e = document.createElement("div");
  e.style = style;
  e.style.position = "absolute";
  e.style.border = "2px dashed rgba(231,236,255,.55)";
  e.style.boxSizing = "border-box";
  e.style.backdropFilter = "blur(4px)";
  e.style.boxShadow = "0 10px 22px rgba(0,0,0,.25)";
  drag(e);
  canvas.appendChild(e);
  items.push(e);
  return e;
}

function addLabel(){
  let e = baseEl(`
    left:10px;top:10px;width:160px;height:48px;
    background:rgba(0,0,0,.35);color:white;
    display:flex;align-items:center;justify-content:center;
    border-radius:14px`);
  e.textContent = "LABEL";
  e.dataset.type = "label";
  e.dataset.font = "1";
  e.dataset.tx = "";
  sel = e; loadProps();
  gen();
}

function addButton(){
  let e = baseEl(`
    left:10px;top:70px;width:160px;height:48px;
    background:rgba(124,92,255,.22);color:white;
    display:flex;align-items:center;justify-content:center;
    border-radius:16px`);
  e.textContent = "BUTTON";
  e.dataset.type = "button";
  e.dataset.font = "1";
  e.dataset.tx = "CMD";
  sel = e; loadProps();
  gen();
}

function addLine(){
  let e = baseEl(`
    left:20px;top:150px;width:100px;height:3px;
    background:#FFFF00;border:none;border-radius:99px`);
  e.dataset.type = "line";
  e.dataset.dir = "h";
  // line shouldn't have dashed border
  e.style.border = "none";
  sel = e; loadProps();
  gen();
}

/* ---------- PROPS ---------- */
function asInt(v, fallback){
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : fallback;
}

function loadProps(){
  if(!sel) return;

  loadingProps = true;

  const type = sel.dataset.type;
  uiProps.style.display   = (type === "line") ? "none" : "block";
  lineProps.style.display = (type === "line") ? "block" : "none";

  if(type !== "line"){
    p_text.value = sel.textContent || "";
    p_tx.value   = sel.dataset.tx || "";
    p_font.value = sel.dataset.font || "1";

    const r = sel.getBoundingClientRect();
    p_w.value = r.width  | 0;
    p_h.value = r.height | 0;

    p_bg.value = colorToHex(sel.style.backgroundColor || "#000");
    p_fg.value = colorToHex(sel.style.color || "#fff");
  } else {
    const r = sel.getBoundingClientRect();
    const w = r.width  | 0;
    const h = r.height | 0;

    p_dir.value = sel.dataset.dir || "h";
    p_len.value = (p_dir.value === "h") ? w : h;
    p_th.value  = (p_dir.value === "h") ? h : w;
    p_lc.value  = colorToHex(sel.style.backgroundColor || "#FFFF00");
  }

  loadingProps = false;
}

function apply(){
  if(loadingProps) return;
  if(!sel) return;

  const type = sel.dataset.type;

  if(type !== "line"){
    sel.textContent = p_text.value ?? "";
    sel.dataset.tx  = p_tx.value ?? "";
    sel.dataset.font = String(asInt(p_font.value, 1));

    const w = Math.max(1, asInt(p_w.value, sel.getBoundingClientRect().width  | 0));
    const h = Math.max(1, asInt(p_h.value, sel.getBoundingClientRect().height | 0));
    sel.style.width  = w + "px";
    sel.style.height = h + "px";

    sel.style.background = p_bg.value || "#000000";
    sel.style.color      = p_fg.value || "#FFFFFF";
  } else {
    const dir = p_dir.value || "h";
    sel.dataset.dir = dir;

    const len = Math.max(1, asInt(p_len.value, 100));
    const th  = Math.max(1, asInt(p_th.value, 3));

    if(dir === "h"){
      sel.style.width  = len + "px";
      sel.style.height = th  + "px";
    } else {
      sel.style.height = len + "px";
      sel.style.width  = th  + "px";
    }

    sel.style.background = p_lc.value || "#FFFF00";
  }

  gen();
}

["p_text","p_tx","p_font","p_w","p_h","p_bg","p_fg","p_len","p_dir","p_th","p_lc"]
  .forEach(id => document.getElementById(id).addEventListener("input", apply));

function del(){
  if(!sel) return;
  if(sel.parentElement === canvas) canvas.removeChild(sel);
  items = items.filter(i => i !== sel);
  sel = null;
  gen();
}

/* ---------- CANVAS BG ---------- */
canvasBgPicker.oninput = ()=>{
  canvas.style.backgroundColor = canvasBgPicker.value;
  gen();
};

/* ---------- CODE GEN ---------- */
function gen(){
  const bgHex = colorToHex(canvas.style.backgroundColor || "#000000");
  let out = [];

  out.push(orientSel.value === "portrait" ? "rotation(0)" : "rotation(1)");
  out.push(`clear(${hexTo0x(bgHex)})`);

  items.forEach(e=>{
    const x = asInt(e.style.left, 0);
    const y = asInt(e.style.top, 0);

    const rect = e.getBoundingClientRect();
    const w = rect.width  | 0;
    const h = rect.height | 0;

    const bgc = hexTo0x(colorToHex(e.style.backgroundColor || "#000000"));
    const fgc = hexTo0x(colorToHex(e.style.color || "#ffffff"));

    if(e.dataset.type === "label"){
      out.push(`label(${x},${y},${w},${h},${bgc},${fgc},${e.textContent},${asInt(e.dataset.font,1)})`);
    }

    if(e.dataset.type === "button"){
      out.push(`button(${x},${y},${w},${h},${bgc},${fgc},${e.textContent},${e.dataset.tx || ""},${asInt(e.dataset.font,1)})`);
    }

    if(e.dataset.type === "line"){
      const dir = e.dataset.dir || "h";
      if(dir === "h"){
        out.push(`line(${x},${y},${x+w},${y},${bgc},${h})`);
      }else{
        out.push(`line(${x},${y},${x},${y+h},${bgc},${w})`);
      }
    }
  });

  codeBox.value = out.join("\n");
}

/* ---------- WEB SERIAL ---------- */
async function connectSerial(){
  port = await navigator.serial.requestPort();
  await port.open({ baudRate:115200 });
  writer = port.writable.getWriter();
  reader = port.readable.getReader();
  keepReading = true;
  readLoop();
  alert("ESP32 Connected");
}

async function disconnectSerial(){
  keepReading = false;
  if(reader){ await reader.cancel(); reader.releaseLock(); }
  if(writer) writer.releaseLock();
  if(port) await port.close();
  alert("Disconnected");
}

async function readLoop(){
  const dec = new TextDecoder();
  let buf = "";
  while(keepReading){
    const {value,done} = await reader.read();
    if(done) break;
    buf += dec.decode(value);
    let lines = buf.split("\n");
    buf = lines.pop();
    lines.forEach(l=>{
      rxBox.value += l + "\n";
      rxBox.scrollTop = rxBox.scrollHeight;
    });
  }
}

async function sendSerial(){
  if(!writer) return alert("Not connected");
  const enc = new TextEncoder();
  for(let l of codeBox.value.split("\n")){
    await writer.write(enc.encode(l + "\n"));
    await new Promise(r=>setTimeout(r,40));
  }
}

/* ---------- INIT ---------- */
gen();
</script>
</body>
</html>
