Skip to content
Chat history


You said:
selam sana projemi tanitmak istiyorum bu web tarafi ve githupta sakliyorum ve oradan link ile acip kullanabiliyorum 
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ESP32 TFT UI Designer</title>
</head>

<body style="margin:0">
<div style="display:flex;height:100vh;font-family:Arial;background:#222;color:#fff">

<!-- SOL PANEL -->
<div style="width:460px;padding:10px">

  <!-- ORIENTATION -->
  Orientation:
  <select id="orientation">
    <option value="landscape" selected>Landscape (320x240)</option>
    <option value="portrait">Portrait (240x320)</option>
  </select>
  <br><br>

  <!-- CANVAS -->
  <div id="canvas" style="
    width:320px;height:240px;
    background:#000;
    border:3px solid #555;
    position:relative;
    margin-bottom:10px"></div>

  Canvas BG:
  <input id="canvas_bg" type="color" value="#000000"><br><br>

  <button onclick="addLabel()">Add Label</button>
  <button onclick="addButton()">Add Button</button>
  <button onclick="addLine()">Add Line</button>
  <br><br>

  <button onclick="connectSerial()">ğŸ”Œ Connect ESP32</button>
  <button onclick="disconnectSerial()">âŒ Disconnect</button>
  <button onclick="sendSerial()">ğŸš€ Send to ESP32</button>

  <textarea id="code" style="width:100%;height:160px;margin-top:10px"></textarea>
</div>

<!-- PROPERTIES -->
<div style="flex:1;padding:10px">
  <h3>Properties</h3>

  <div id="uiProps">
    Text <input id="p_text"><br>
    TX <input id="p_tx"><br>
    Font
    <select id="p_font">
      <option value="0">FreeSans9pt</option>
      <option value="1" selected>FreeSans12pt</option>
      <option value="2">FreeSans18pt</option>
      <option value="3">FreeSansBold</option>
      <option value="4">FreeMonoOblique24pt</option>
      <option value="5">FreeSans24pt</option>
      <option value="6">FreeSansOblique12pt</option>
      <option value="7">FreeSerifBold24pt</option>
      <option value="8">TomThumb</option>
      <option value="9">Tiny3x3a2pt</option>
      <option value="10">Picopixel</option>
      <option value="11">Org_01</option>
    </select><br>
    Width <input id="p_w" type="number"><br>
    Height <input id="p_h" type="number"><br>
    BG <input id="p_bg" type="color"><br>
    FG <input id="p_fg" type="color"><br>
  </div>

  <div id="lineProps" style="display:none">
    Length <input id="p_len" type="number"><br>
    Direction
    <select id="p_dir">
      <option value="h">Horizontal</option>
      <option value="v">Vertical</option>
    </select><br>
    Thickness <input id="p_th" type="number"><br>
    Color <input id="p_lc" type="color"><br>
  </div>

  <br>
  <button onclick="del()">ğŸ—‘ Delete</button>

  <h3>Serial Monitor (RX)</h3>
  <textarea id="rx"
    style="width:100%;height:180px;
    background:#111;color:#0f0;
    font-family:monospace"></textarea>
</div>
</div>

<script>
/* ---------- STATE ---------- */
const canvas = document.getElementById("canvas");
const codeBox = document.getElementById("code");
const rxBox = document.getElementById("rx");
const canvasBgPicker = document.getElementById("canvas_bg");
const orientSel = document.getElementById("orientation");
let items=[], sel=null;

/* ---------- ORIENTATION ---------- */
orientSel.onchange = ()=>{
  if(orientSel.value=="portrait"){
    canvas.style.width="240px";
    canvas.style.height="320px";
  }else{
    canvas.style.width="320px";
    canvas.style.height="240px";
  }
  gen();
}

/* ---------- SERIAL ---------- */
let port, writer, reader, keepReading=false;

/* ---------- HELPERS ---------- */
function rgb(c){
  let ctx=document.createElement("canvas").getContext("2d");
  ctx.fillStyle=c; return ctx.fillStyle;
}

/* ---------- DRAG ---------- */
function drag(el){
  let ox,oy;
  el.onmousedown=e=>{
    sel=el; loadProps();
    ox=e.offsetX; oy=e.offsetY;
    document.onmousemove=ev=>{
      el.style.left=ev.pageX-canvas.offsetLeft-ox+"px";
      el.style.top =ev.pageY-canvas.offsetTop -oy+"px";
      gen();
    }
    document.onmouseup=()=>document.onmousemove=null;
  }
}

/* ---------- ADD ---------- */
function baseEl(style){
  let e=document.createElement("div");
  e.style=style;
  e.style.position="absolute";
  e.style.border="2px dashed #aaa";
  drag(e);
  canvas.appendChild(e);
  items.push(e);
  return e;
}

function addLabel(){
  let e=baseEl(
    left:10px;top:10px;width:160px;height:48px;
    background:black;color:white;
    display:flex;align-items:center;justify-content:center;
    border-radius:8px);
  e.textContent="LABEL";
  e.dataset.type="label";
  e.dataset.font=1;
  e.dataset.tx="";
  gen();
}

function addButton(){
  let e=baseEl(
    left:10px;top:70px;width:160px;height:48px;
    background:black;color:white;
    display:flex;align-items:center;justify-content:center;
    border-radius:8px);
  e.textContent="BUTTON";
  e.dataset.type="button";
  e.dataset.font=1;
  e.dataset.tx="CMD";
  gen();
}

function addLine(){
  let e=baseEl(
    left:20px;top:150px;width:100px;height:3px;
    background:yellow;border:none);
  e.dataset.type="line";
  e.dataset.dir="h";
  gen();
}

/* ---------- PROPS ---------- */
function loadProps(){
  if(!sel) return;
  uiProps.style.display=sel.dataset.type=="line"?"none":"block";
  lineProps.style.display=sel.dataset.type=="line"?"block":"none";

  if(sel.dataset.type!="line"){
    p_text.value=sel.textContent;
    p_tx.value=sel.dataset.tx;
    p_font.value=sel.dataset.font;
    p_w.value=sel.offsetWidth;
    p_h.value=sel.offsetHeight;
    p_bg.value=rgb(sel.style.backgroundColor);
    p_fg.value=rgb(sel.style.color);
  }else{
    p_len.value=sel.dataset.dir=="h"?sel.offsetWidth:sel.offsetHeight;
    p_th.value=sel.dataset.dir=="h"?sel.offsetHeight:sel.offsetWidth;
    p_dir.value=sel.dataset.dir;
    p_lc.value=rgb(sel.style.backgroundColor);
  }
}

function apply(){
  if(!sel) return;
  if(sel.dataset.type!="line"){
    sel.textContent=p_text.value;
    sel.dataset.tx=p_tx.value;
    sel.dataset.font=p_font.value;
    sel.style.width=p_w.value+"px";
    sel.style.height=p_h.value+"px";
    sel.style.background=p_bg.value;
    sel.style.color=p_fg.value;
  }else{
    sel.dataset.dir=p_dir.value;
    if(p_dir.value=="h"){
      sel.style.width=p_len.value+"px";
      sel.style.height=p_th.value+"px";
    }else{
      sel.style.height=p_len.value+"px";
      sel.style.width=p_th.value+"px";
    }
    sel.style.background=p_lc.value;
  }
  gen();
}

["p_text","p_tx","p_font","p_w","p_h","p_bg","p_fg","p_len","p_dir","p_th","p_lc"]
.forEach(id=>document.getElementById(id).oninput=apply);

function del(){
  if(!sel) return;
  canvas.removeChild(sel);
  items=items.filter(i=>i!=sel);
  sel=null;
  gen();
}

/* ---------- CANVAS BG ---------- */
canvasBgPicker.oninput=()=>{
  canvas.style.backgroundColor=canvasBgPicker.value;
  gen();
}

/* ---------- CODE GEN ---------- */
function gen(){
  let bg=rgb(canvas.style.backgroundColor).slice(1).toUpperCase();
  let out=[];

  out.push(
    orientSel.value=="portrait" ? "rotation(0)" : "rotation(1)"
  );

  out.push(clear(0x${bg}));

  items.forEach(e=>{
    let x=parseInt(e.style.left),
        y=parseInt(e.style.top),
        w=e.offsetWidth,
        h=e.offsetHeight;

    let bgc=rgb(e.style.backgroundColor).slice(1).toUpperCase();
    let fgc=rgb(e.style.color||"#fff").slice(1).toUpperCase();

    if(e.dataset.type=="label")
      out.push(label(${x},${y},${w},${h},0x${bgc},0x${fgc},${e.textContent},${e.dataset.font}));

    if(e.dataset.type=="button")
      out.push(button(${x},${y},${w},${h},0x${bgc},0x${fgc},${e.textContent},${e.dataset.tx},${e.dataset.font}));

    if(e.dataset.type=="line"){
      if(e.dataset.dir=="h")
        out.push(line(${x},${y},${x+w},${y},0x${bgc},${h}));
      else
        out.push(line(${x},${y},${x},${y+h},0x${bgc},${w}));
    }
  });

  codeBox.value=out.join("\n");
}

/* ---------- WEB SERIAL ---------- */
async function connectSerial(){
  port=await navigator.serial.requestPort();
  await port.open({ baudRate:115200 });
  writer=port.writable.getWriter();
  reader=port.readable.getReader();
  keepReading=true;
  readLoop();
  alert("ESP32 Connected");
}

async function disconnectSerial(){
  keepReading=false;
  if(reader){ await reader.cancel(); reader.releaseLock(); }
  if(writer) writer.releaseLock();
  if(port) await port.close();
  alert("Disconnected");
}

async function readLoop(){
  const dec=new TextDecoder();
  let buf="";
  while(keepReading){
    const {value,done}=await reader.read();
    if(done) break;
    buf+=dec.decode(value);
    let lines=buf.split("\n");
    buf=lines.pop();
    lines.forEach(l=>{
      rxBox.value+=l+"\n";
      rxBox.scrollTop=rxBox.scrollHeight;
    });
  }
}

async function sendSerial(){
  if(!writer) return alert("Not connected");
  const enc=new TextEncoder();
  for(let l of codeBox.value.split("\n")){
    await writer.write(enc.encode(l+"\n"));
    await new Promise(r=>setTimeout(r,40));
  }
}
</script>
</body>
</html>
ChatGPT said:
Selam Burak â€” projeyi anladÄ±m: tarayÄ±cÄ±da sÃ¼rÃ¼kle-bÄ±rak ile UI Ã§iziyorsun, sonra da Web Serial (navigator.serial) ile ESP32â€™ye satÄ±r satÄ±r komut gÃ¶nderip ekranda aynÄ± arayÃ¼zÃ¼ Ã§izdiriyorsun. MantÄ±k Ã§ok temiz: web tarafÄ± â€œdesigner + code generatorâ€, ESP32 tarafÄ± da â€œkomut yorumlayÄ±cÄ± + TFT rendererâ€.

AÅŸaÄŸÄ±ya hem projenin ÅŸu an nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± net Ã¶zetleyeyim, hem de birkaÃ§ kritik iyileÅŸtirme bÄ±rakayÄ±m (Ã¶zellikle GitHub Pagesâ€™te Ã§alÄ±ÅŸtÄ±rma, hata/uyumluluk, komut formatÄ±, gÃ¼venli gÃ¶nderim vs.)

Proje akÄ±ÅŸÄ± (senin koduna gÃ¶re)
1) Canvas tarafÄ± (sol panel)
#canvas aslÄ±nda bir â€œsahte TFT ekranâ€ gibi Ã§alÄ±ÅŸÄ±yor.

addLabel / addButton / addLine ile iÃ§ine div elemanlarÄ± ekliyorsun.

Her elemanÄ±n:

style.left/top/width/height â†’ konum ve boyut

dataset.type â†’ label/button/line

dataset.font, dataset.tx â†’ ESP32â€™ye gÃ¶nderilecek parametreler

drag() fonksiyonu ile mouse sÃ¼rÃ¼kleme yapÄ±nca konum gÃ¼ncelleniyor ve gen() tekrar Ã§alÄ±ÅŸÄ±yor.

2) Properties panel (saÄŸ panel)
SeÃ§ili element sel ile takip ediliyor.

loadProps() seÃ§ilen elementin bilgilerini inputâ€™lara basÄ±yor.

Inputâ€™lar deÄŸiÅŸince apply() ile elemanÄ±n style/dataset alanlarÄ± gÃ¼ncelleniyor.

Her deÄŸiÅŸiklik gen() Ã§aÄŸÄ±rÄ±yor.

3) Code generator (gen)
gen() her ÅŸeyi bir â€œkomut listesiâ€ne Ã§eviriyor:

Ã–nce:

rotation(0) / rotation(1)

clear(0xXXXXXX)

Sonra her eleman iÃ§in:

label â†’ label(x,y,w,h,bg,fg,text,font)

button â†’ button(x,y,w,h,bg,fg,text,tx,font)

line â†’ line(x1,y1,x2,y2,color,thickness)

Ve bu komutlarÄ± textarea#code iÃ§ine yazÄ±yor.

4) Web Serial ile ESP32â€™ye gÃ¶nderim
connectSerial() â†’ port seÃ§tiriyor, 115200 aÃ§Ä±yor, reader/writer alÄ±yor.

readLoop() â†’ ESP32â€™den gelen satÄ±rlarÄ± RX monitÃ¶re basÄ±yor.

sendSerial() â†’ code satÄ±r satÄ±r gÃ¶nderiyor, her satÄ±r arasÄ± 40ms bekliyor.

Bu sistemin gÃ¼Ã§lÃ¼ taraflarÄ±
ESP32 tarafÄ±nÄ± yormuyorsun: UI edit + layout webâ€™de, ESP32 sadece Ã§iziyor.

Komut dili yaklaÅŸÄ±mÄ± Ã§ok doÄŸru: yarÄ±n Ã¶bÃ¼r gÃ¼n â€œslider, image, iconâ€ eklemek kolay.

Serial monitor eklemen harika: debug/ack sistemine Ã§ok uygun.

Dikkat edilmesi gereken 6 kritik nokta (hepsi sende ÅŸu an â€œgizli bugâ€ olarak duruyor)
1) GitHub Pages ve Web Serial gerÃ§eÄŸi
Web Serial yalnÄ±zca HTTPS veya localhost Ã¼zerinde Ã§alÄ±ÅŸÄ±yor.
GitHub Pages HTTPS olduÄŸu iÃ§in Ã§alÄ±ÅŸÄ±r, ama:

Safariâ€™de yok, Firefoxâ€™ta yok â†’ Chrome/Edge ÅŸart.

KullanÄ±cÄ± â€œConnectâ€ butonuna tÄ±klamadan port seÃ§tiremezsin (doÄŸru yapmÄ±ÅŸsÄ±n).

2) rgb() fonksiyonun hex deÄŸil, tarayÄ±cÄ± â€œnormalizeâ€ ediyor
Sen rgb(c) ile ctx.fillStyle=c; return ctx.fillStyle; diyorsun.
Bu bazen:

#00ff00 dÃ¶ndÃ¼rÃ¼r,

bazen rgb(0, 255, 0) dÃ¶ndÃ¼rÃ¼r.
Sonra slice(1) yapÄ±nca rgb(â€¦ patlar.

Bunu bazÄ± tarayÄ±cÄ±larda Ã§ok net gÃ¶rÃ¼rsÃ¼n. En saÄŸlam Ã§Ã¶zÃ¼m:

r,g,bâ€™yi alÄ±p kesin #RRGGBB Ã¼retmek.

3) Komutlarda text ve tx â€œtÄ±rnaksÄ±zâ€
Åu an:

label(..., ${e.textContent}, ...)
Bu Ã¼retimde:

LABEL tÄ±rnaksÄ±z gidiyor â†’ ESP32 parser â€œstringâ€ bekliyorsa zorlanÄ±r.

Metinde boÅŸluk/virgÃ¼l/parantez olursa komut kÄ±rÄ±lÄ±r.

En gÃ¼venlisi:

Text ve txâ€™leri "..." ÅŸeklinde gÃ¶nderip

Ä°Ã§eride \" kaÃ§Ä±ÅŸlamak.

4) parseInt(e.style.left) bazen NaN olabilir
EÄŸer elemente left/top hiÃ§ set edilmezse (ya da browser bir an boÅŸ bÄ±rakÄ±rsa) NaN dÃ¶ner.
Sen baseElâ€™de left/top veriyorsun, ama ileride â€œsnap / align / resetâ€ eklersen bu patlar.
Ä°yi pratik: || 0 fallback.

5) ESP32â€™ye satÄ±r satÄ±r kÃ¶r gÃ¶ndermek yerine ACK sistemi
40ms delay bazen yetmez, bazen gereksiz yavaÅŸlatÄ±r.
En saÄŸlam yÃ¶ntem:

Her komut sonrasÄ± ESP32 OK\n dÃ¶ndÃ¼rsÃ¼n.

Web tarafÄ± bir sonraki komutu â€œOK gelinceâ€ yollasÄ±n.
Bu ÅŸekilde:

buffer taÅŸmasÄ± olmaz,

hÄ±z otomatik optimum olur.

6) document.onmousemove global kaldÄ±ÄŸÄ± iÃ§in bazen â€œtakÄ±lÄ± kalÄ±râ€
Mouse leave / iframe / focus kaybÄ±nda sÃ¼rÃ¼kleme takÄ±lÄ± kalabilir.
Bunu addEventListener + pointerdown/pointermove/pointerup ile daha stabil yaparsÄ±n.

En hÄ±zlÄ± geliÅŸtirme Ã¶nerisi (projenin seviyesini bir anda yÃ¼kseltir)
Ben olsam 3 ÅŸey eklerdim:

Komut formatÄ±nÄ± JSON Lines yap
Ã–rn:

{"cmd":"label","x":10,"y":10,"w":160,"h":48,"bg":"#000000","fg":"#ffffff","text":"LABEL","font":1}
Parser Ã§ok rahatlar,

string kaÃ§Ä±ÅŸ derdi azalÄ±r,

gelecekte â€œimage/base64/icon idâ€ gibi ÅŸeyleri taÅŸÄ±mak kolaylaÅŸÄ±r.

Export / Import (Save Layout)

â€œExport JSONâ€ butonu â†’ tÃ¼m items dataset + style bilgilerini indir.

â€œImport JSONâ€ â†’ layoutâ€™u geri yÃ¼kle.
Bu senin projeyi â€œgerÃ§ek Ã¼rÃ¼nâ€ yapar.

Snap-to-grid ve hizalama

5px grid, align left/center/right

UX inanÄ±lmaz artar.

Ä°stersen bir sonraki adÄ±m: ESP32 tarafÄ± protokolÃ¼nÃ¼ saÄŸlamlaÅŸtÄ±ralÄ±m
Senin web kodu â€œkomut diliâ€ Ã¼retiyor. Ben de sana:

ESP32 tarafÄ±nda satÄ±r okuyup parse eden

label/button/line/clear/rotation Ã§izen

her komut sonrasÄ± OK dÃ¶nen
Ã¶rnek bir â€œparser + dispatcherâ€ ÅŸablonu Ã§Ä±karabilirim.

Bana sadece ÅŸunu sÃ¶ylemen yeter:

TFT kÃ¼tÃ¼phanen ne? TFT_eSPI mi, LovyanGFX mi?

Ekran sÃ¼rÃ¼cÃ¼: ST7789 / ILI9341 vs. (senin kartta hangisi?)

Ä°stersen ayrÄ±ca: â€œButtonâ€™a tÄ±klanÄ±nca ESP32â€™ye tx gÃ¶ndermekâ€ (dokunmatik varsa) veya â€œESP32â€™den gelen stateâ€™e gÃ¶re webâ€™de highlightâ€ gibi iki yÃ¶nlÃ¼ hale de getiririz.

You said:
buda esp32 nin icinde ki kod 
/*
ESP32 TFT UI Client
- Bluetooth Ã¼zerinden komut alÄ±r
- Dokunmatik ekran ile butonlara basÄ±labilir
- Gelen komutlarÄ± seri monitÃ¶re yazdÄ±rÄ±r
*/

#include <Arduino_GFX_Library.h>
#include <XPT2046_Touchscreen.h>
#include <SPI.h>

#include "Fonts/FreeSans9pt7b.h"
#include "Fonts/FreeSans12pt7b.h"
#include "Fonts/FreeSans18pt7b.h"
#include "Fonts/FreeSansBold9pt7b.h"

#include "Fonts/FreeMonoOblique24pt7b.h"
#include "Fonts/FreeSans24pt7b.h"
#include "Fonts/FreeSansOblique12pt7b.h"
#include "Fonts/FreeSerifBold24pt7b.h"
#include "Fonts/TomThumb.h"
#include "Fonts/Tiny3x3a2pt7b.h"
#include "Fonts/Picopixel.h"
#include "Fonts/Org_01.h"

#include "BluetoothSerial.h"

/* ===================== BLUETOOTH ===================== */
BluetoothSerial SerialBT;
uint8_t serverAddress[6] = {0x00, 0x4B, 0x12, 0xEE, 0x4E, 0x12};

/* ===================== TFT ===================== */
#define TFT_CS   15
#define TFT_DC   2
#define TFT_SCK  14
#define TFT_MOSI 13
#define TFT_MISO 12
#define TFT_RST  -1
#define TFT_BL   21
#define BACKLIGHT_ON() digitalWrite(TFT_BL, HIGH)

/* ===================== TOUCH ===================== */
#define TOUCH_CS   33
#define TOUCH_IRQ  36
#define TOUCH_SCK  25
#define TOUCH_MOSI 32
#define TOUCH_MISO 39

Arduino_DataBus *bus = new Arduino_ESP32SPI(
  TFT_DC, TFT_CS, TFT_SCK, TFT_MOSI, TFT_MISO
);
Arduino_GFX *gfx = new Arduino_ILI9341(bus, TFT_RST, 1, false);
XPT2046_Touchscreen ts(TOUCH_CS, TOUCH_IRQ);

/* ===================== FONT SETÄ° ===================== */
const GFXfont* FONTS[] = {
  &FreeSans9pt7b,
  &FreeSans12pt7b,
  &FreeSans18pt7b,
  &FreeSansBold9pt7b,
  &FreeMonoOblique24pt7b,
  &FreeSans24pt7b,
  &FreeSansOblique12pt7b,
  &FreeSerifBold24pt7b,
  &TomThumb,
  &Tiny3x3a2pt7b,
  &Picopixel,
  &Org_01
};

/* ===================== UI ===================== */
enum ElementType { LABEL, BUTTON };

struct UIElement {
  ElementType type;
  int x, y, w, h;
  uint16_t bg, tc;
  String text, tx;
  int fontID;
};

#define MAX_ELEMENTS 50
UIElement elements[MAX_ELEMENTS];
int elementCount = 0;

/* ===================== HEX â†’ RGB565 ===================== */
uint16_t hexTo565(String hex) {
  hex.replace("#", "");
  if (hex.startsWith("0x")) hex = hex.substring(2);
  long rgb = strtol(hex.c_str(), NULL, 16);
  uint8_t r = (rgb >> 16) & 0xFF;
  uint8_t g = (rgb >> 8) & 0xFF;
  uint8_t b = rgb & 0xFF;
  return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
}

/* ===================== PARSE ===================== */
String getArg(String &s, int index) {
  int from = 0;
  for (int i = 0; i < index; i++) {
    from = s.indexOf(',', from) + 1;
    if (from <= 0) return "";
  }
  int to = s.indexOf(',', from);
  if (to == -1) to = s.length();
  return s.substring(from, to);
}

/* ===================== Ã‡Ä°ZÄ°M ===================== */
void drawTextBox(UIElement &e, bool rounded) {
  gfx->setFont(FONTS[e.fontID]);
  gfx->setTextColor(e.tc);

  if (rounded) {
    gfx->fillRoundRect(e.x, e.y, e.w, e.h, 12, e.bg);
    gfx->drawRoundRect(e.x, e.y, e.w, e.h, 12, e.tc);
  } else {
    gfx->fillRect(e.x, e.y, e.w, e.h, e.bg);
  }

  int16_t x1, y1;
  uint16_t tw, th;
  gfx->getTextBounds(e.text, 0, 0, &x1, &y1, &tw, &th);
  gfx->setCursor(e.x + (e.w - tw) / 2, e.y + (e.h + th) / 2 - 2);
  gfx->print(e.text);
}

void redrawAll() {
  for (int i = 0; i < elementCount; i++)
    drawTextBox(elements[i], elements[i].type == BUTTON);
}

void drawLineCmd(int x0,int y0,int x1,int y1,uint16_t c,int t) {
  for (int i = 0; i < max(1, t); i++)
    gfx->drawLine(x0, y0 + i, x1, y1 + i, c);
}

/* ===================== EKLE ===================== */
void addLabel(int x,int y,int w,int h,String bg,String tc,String text,int fontID) {
  elements[elementCount++] = { LABEL, x,y,w,h, hexTo565(bg), hexTo565(tc), text,"",fontID };
  drawTextBox(elements[elementCount - 1], false);
}

void addButton(int x,int y,int w,int h,String bg,String tc,String text,String tx,int fontID) {
  elements[elementCount++] = { BUTTON, x,y,w,h, hexTo565(bg), hexTo565(tc), text,tx,fontID };
  drawTextBox(elements[elementCount - 1], true);
}

/* ===================== KOMUT ===================== */
void processCommand(String cmd) {
  cmd.trim();
  if (!cmd.length()) return;

  Serial.println("Processing: " + cmd);

  if (cmd.startsWith("rotation(")) {
    int r = cmd.substring(9, cmd.indexOf(')')).toInt();
    gfx->setRotation(r);
    ts.setRotation(r);
    gfx->fillScreen(0x0000);
    redrawAll();
  }

  else if (cmd.startsWith("clear(")) {
    gfx->fillScreen(hexTo565(cmd.substring(6, cmd.indexOf(')'))));
    elementCount = 0;
  }

  else if (cmd.startsWith("line(")) {
    String p = cmd.substring(5, cmd.indexOf(')'));
    drawLineCmd(
      getArg(p,0).toInt(), getArg(p,1).toInt(),
      getArg(p,2).toInt(), getArg(p,3).toInt(),
      hexTo565(getArg(p,4)), getArg(p,5).toInt()
    );
  }

  else if (cmd.startsWith("label(")) {
    String p = cmd.substring(6, cmd.indexOf(')'));
    addLabel(
      getArg(p,0).toInt(), getArg(p,1).toInt(),
      getArg(p,2).toInt(), getArg(p,3).toInt(),
      getArg(p,4), getArg(p,5),
      getArg(p,6), getArg(p,7).toInt()
    );
  }

  else if (cmd.startsWith("button(")) {
    String p = cmd.substring(7, cmd.indexOf(')'));
    addButton(
      getArg(p,0).toInt(), getArg(p,1).toInt(),
      getArg(p,2).toInt(), getArg(p,3).toInt(),
      getArg(p,4), getArg(p,5),
      getArg(p,6), getArg(p,7),
      getArg(p,8).toInt()
    );
  }
}

/* ===================== SETUP ===================== */
void setup() {
  Serial.begin(115200);
  pinMode(TFT_BL, OUTPUT);
  BACKLIGHT_ON();

  gfx->begin();
  gfx->setRotation(1);
  ts.setRotation(1);
  gfx->fillScreen(0x0000);

  gfx->setFont(&FreeSans12pt7b);
  gfx->setTextColor(0xFFFF);
  gfx->setCursor(20, gfx->height() / 2);
  gfx->print("Waiting for commands...");

  SPI.begin(TOUCH_SCK, TOUCH_MISO, TOUCH_MOSI, TOUCH_CS);
  ts.begin();

  SerialBT.begin("ESP32_UI_CLIENT", true);
  SerialBT.connect(serverAddress);

  Serial.println("Setup complete.");
}

/* ===================== LOOP ===================== */
void loop() {
  if (ts.touched()) {
    TS_Point p = ts.getPoint();
    int px = map(p.x, 300, 3800, 0, gfx->width());
    int py = map(p.y, 300, 3800, 0, gfx->height());

    for (int i = 0; i < elementCount; i++) {
      UIElement &e = elements[i];
      if (e.type == BUTTON &&
          px > e.x && px < e.x + e.w &&
          py > e.y && py < e.y + e.h) {
        SerialBT.println(e.tx);
        Serial.println("Button pressed: " + e.tx);
        delay(300);
      }
    }
  }

  while (SerialBT.available())
    processCommand(SerialBT.readStringUntil('\n'));

  while (Serial.available())
    processCommand(Serial.readStringUntil('\n'));
}
ChatGPT said:
SÃ¼per Burak â€” ÅŸimdi tablo tamamlandÄ±: Web tarafÄ±n komut Ã¼retiyor, ESP32 tarafÄ±n hem BT (SerialBT) hem USB Serial Ã¼zerinden aynÄ± komutlarÄ± parse edip Ã§iziyor, ayrÄ±ca dokunmatik ile buttonâ€™lara basÄ±nca tx deÄŸerini Bluetoothâ€™tan geri yolluyor. MantÄ±k Ã§ok dÃ¼zgÃ¼n.

Ama iki tarafta da â€œyarÄ±n sorun Ã§Ä±karacakâ€ birkaÃ§ kritik nokta var. En Ã¶nemlileri: string parsing, elementCount taÅŸmasÄ±, clear sonrasÄ± Ã§izim, web tarafÄ±nÄ±n tÄ±rnaksÄ±z text/tx gÃ¶ndermesi, ve renk formatÄ±.

AÅŸaÄŸÄ±da net ÅŸekilde, senin koduna gÃ¶re â€œne iyi / ne riskli / nasÄ±l dÃ¼zeltirizâ€ anlatÄ±yorum.

Åu haliyle ESP32 kodunun gÃ¼Ã§lÃ¼ yanlarÄ±
Komut dili basit: rotation/clear/label/button/line

UI elementlerini RAMâ€™de tutup redrawAll() ile tekrar Ã§izebiliyorsun

Touch â†’ button hit-test â†’ SerialBT.println(e.tx) gÃ¼zel

Font tablolu sistem iyi (fontID ile seÃ§mek pratik)

1) En bÃ¼yÃ¼k risk: getArg() virgÃ¼le gÃ¶re bÃ¶lÃ¼yor (text/tx patlar)
Åu an getArg() sadece virgÃ¼l ile argÃ¼man ayÄ±rÄ±yor. Bu demek ki:

Label textâ€™i â€œHELLO BURAKâ€ (boÅŸluk) sorun deÄŸil

ama â€œHELLO, BURAKâ€ (virgÃ¼l) varsa parametreler kayar

veya buton tx iÃ§inde virgÃ¼l varsa aynÄ±

AyrÄ±ca web tarafÄ±nda label(..., ${e.textContent}, ...) tÄ±rnaksÄ±z gÃ¶nderiyor.
Bu da hem parseâ€™Ä± kÄ±rar, hem de ileride text iÃ§inde Ã¶zel karakter olunca zorlar.

En saÄŸlam Ã§Ã¶zÃ¼m: text ve txâ€™yi tÄ±rnaklÄ± gÃ¶nder ve ESP32â€™de tÄ±rnak iÃ§ini tek argÃ¼man sayan parser yaz.

Mini upgrade mantÄ±ÄŸÄ±:

Komut: label(10,10,160,48,0x000000,0xFFFFFF,"HELLO BURAK",1)

Buton: button(...,"BUTTON","CMD:START",1)

Ä°stersen ben sana getArgQuoted() gibi, tÄ±rnak destekli bir parser fonksiyonu yazÄ±p doÄŸrudan senin koda entegre edeyim.

2) MAX_ELEMENTS taÅŸarsa bellek bozulur (ÅŸu an kontrol yok)
addLabel/addButton iÃ§inde:

elements[elementCount++] = ...
Ama elementCount 50â€™yi geÃ§erse dizi dÄ±ÅŸÄ±na yazar â†’ random reset / garip Ã§izimler.

Mutlaka:

if (elementCount >= MAX_ELEMENTS) return;
veya â€œclearâ€ yapÄ±p tekrar baÅŸlat.

3) clear() elementCount=0 yapÄ±yor ama ekrandaki Ã§izgileri/Ã§izimleri resetliyor mu?
Sen clear() yapÄ±nca ekranÄ± dolduruyorsun ve elementCount=0 yapÄ±yorsun. Ä°yi.
Ama line() Ã§izdiÄŸin ÅŸeyler elements iÃ§ine kaydedilmiyor.
Yani:

rotation deÄŸiÅŸirse redrawAll() sadece label/button Ã§izer

lineâ€™lar kaybolur

Web tarafÄ±nda line var, ama ESP32â€™de line â€œstatelessâ€.

Ã‡Ã¶zÃ¼m seÃ§enekleri:

Lineâ€™Ä± da UIElement gibi sakla (enumâ€™a LINE ekle)

Ya da â€œrotation deÄŸiÅŸince web tekrar send yapsÄ±nâ€ de (pratik ama zayÄ±f)

En iyisi: Lineâ€™Ä± da elements iÃ§ine ekle

4) hexTo565() gayet iyi ama web tarafÄ± bazen rgb(0,0,0) gÃ¶nderebilir
ESP32 tarafÄ± hex bekliyor: 0xAABBCC veya #AABBCC.
EÄŸer web tarafÄ±nda rgb(...) gibi bir string gelirse strtol Ã§Ã¶p okur.

Bu yÃ¼zden web tarafÄ±nda kesin 0xRRGGBB Ã¼retmek ÅŸart.

5) Bluetooth connect kÄ±smÄ±: â€œclient modeâ€ + sabit MAC
Sen:

SerialBT.begin("ESP32_UI_CLIENT", true);
SerialBT.connect(serverAddress);
Burada true â†’ cihaz BT Classicâ€™te master/client oluyor.
Bu mantÄ±k doÄŸru ama pratikte ÅŸu riskler var:

karÅŸÄ± cihaz (server) yoksa connect takÄ±lÄ± kalabilir / geÃ§ baÄŸlanÄ±r

MAC deÄŸiÅŸirse kopar

web tarafÄ±n ÅŸu an Web Serial kullanÄ±yor; BT Ã¼zerinden web direkt konuÅŸamaz (tarayÄ±cÄ± BT Classic desteklemez)

Yani ÅŸu an web->ESP32 en sorunsuz yol USB Serial.
Bluetoothâ€™u daha Ã§ok â€œESP32->baÅŸka ESP32 / telefon app / PC appâ€ iÃ§in dÃ¼ÅŸÃ¼nmek doÄŸru.

6) Touch map kalibrasyonu sabit (300-3800)
Bu deÄŸerler her ekranda farklÄ± Ã§Ä±kabiliyor. Bir ekranda basma kayar.
Buna bir kalibrasyon komutu iyi olur:

touchcal(xmin,xmax,ymin,ymax) gibi
veya config.

7) Ufak ama Ã¶nemli: readStringUntil('\n') bloklayabilir
Serial ve BTâ€™de:

processCommand(SerialBT.readStringUntil('\n'));
Bu fonksiyon timeout bekleyebilir (default ~1s) ve loopâ€™u geciktirebilir.
Daha saÄŸlamÄ±:

satÄ±r bufferâ€™Ä± toplayÄ±p \n gelince iÅŸlemek (non-blocking)

Ama â€œÅŸimdilik basitâ€ iÃ§in sorun deÄŸil; UI hÄ±zlanÄ±nca fark edilir.

Sana en mantÄ±klÄ± â€œhemenâ€ iyileÅŸtirme paketi (en az deÄŸiÅŸiklikle)
Web tarafÄ±nda text/txâ€™yi tÄ±rnakla gÃ¶nder:

"LABEL" "CMD"

ESP32 tarafÄ±nda tÄ±rnak iÃ§ini tek argÃ¼man sayan parser

MAX_ELEMENTS guard

Lineâ€™Ä± da elements iÃ§ine kaydet

BunlarÄ± yapÄ±nca sistemin â€œÃ¼rÃ¼n gibiâ€ stabil olur.

Ä°stersen ben direkt iki dosyaya da patch hazÄ±rlayayÄ±m
Senin hedefin ÅŸu mu?

Web Designerâ€™dan â€œSend to ESP32â€ dediÄŸinde tam layout her seferinde temiz Ã§izilsin,

rotation deÄŸiÅŸince line dahil her ÅŸey geri gelsin,

text/tx iÃ§inde TÃ¼rkÃ§e/boÅŸluk/virgÃ¼l olsa bile bozulmasÄ±n,

ESP32 her komuttan sonra OK dÃ¶nsÃ¼n ve web â€œOK bekleyipâ€ gÃ¶ndermeye devam etsin (buffer taÅŸmasÄ±n)

EÄŸer â€œevetâ€ dersen ben sana:

web tarafÄ± gen() Ã§Ä±ktÄ±sÄ±nÄ± tÄ±rnaklÄ± + escapeâ€™li

ESP32 tarafÄ± quoted parser + OK handshake
ÅŸeklinde, kopyala-yapÄ±ÅŸtÄ±r hazÄ±r kodu Ã§Ä±karÄ±rÄ±m.

You said:
senden istedigim web tarafinda bir button ekliyorum . yan panelden boyutunu ayarliyorum . sonra ayni buttona basinca button boyutlari degisiyor labeldada ayni line dada ayni neden sence
ChatGPT said:
Bu davranÄ±ÅŸÄ±n %90 ihtimalle â€œyan panel inputâ€™larÄ± ile elementin Ã¼stÃ¼ne tÄ±klama olayÄ± Ã§akÄ±ÅŸÄ±yorâ€ ve senin drag() fonksiyonun sadece sÃ¼rÃ¼kleme iÃ§in deÄŸil, tÄ±klayÄ±nca da sel=el + loadProps() Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ± iÃ§in â€œtÄ±klar tÄ±klamaz apply() tekrar devreye giriyorâ€. Yani sen elemente tÄ±klayÄ±nca, paneldeki deÄŸerler bir an eski/boÅŸ/NaN gibi okunup tekrar elemana yazÄ±lÄ±yor â†’ boyut zÄ±plÄ±yor.

Kodunda bunu tetikleyebilecek 3 net sebep var:

1) drag() iÃ§inde e.offsetX / e.offsetY kullanÄ±yorsun (en yaygÄ±n sebep)
el.onmousedown = e=>{
  sel=el; loadProps();
  ox=e.offsetX; oy=e.offsetY;
  document.onmousemove = ev=>{
    el.style.left = ev.pageX - canvas.offsetLeft - ox + "px";
    el.style.top  = ev.pageY - canvas.offsetTop  - oy + "px";
    gen();
  }
}
Problem:
e.offsetX / offsetY tÄ±klanan alt elemente gÃ¶re deÄŸiÅŸir.

Senin label/button divâ€™lerinde:

display:flex; align-items:center; justify-content:center;
Ve iÃ§inde text var. TÄ±klayÄ±nca bazen olay div Ã¼zerinde, bazen text node / farklÄ± render alanÄ±nda hesaplanÄ±yor; offset hesabÄ± farklÄ± Ã§Ä±kÄ±yor. Mouseâ€™u 1 piksel bile oynatsan, document.onmousemove devreye girip left/top yeniden hesaplanÄ±yor â†’ element â€œyer deÄŸiÅŸtiriyorâ€. Sen de bunu â€œboyut deÄŸiÅŸtiâ€ gibi algÄ±lÄ±yorsun (Ã§oÄŸu zaman hem yer hem Ã¶lÃ§Ã¼ algÄ±sÄ± karÄ±ÅŸÄ±r).

âœ… Ã‡Ã¶zÃ¼m:
offsetX/offsetY yerine bounding rect ile gerÃ§ek farkÄ± al:

function drag(el){
  let startX, startY, startLeft, startTop;

  el.onmousedown = (e) => {
    sel = el; loadProps();

    const r = el.getBoundingClientRect();
    const c = canvas.getBoundingClientRect();

    startX = e.clientX;
    startY = e.clientY;
    startLeft = r.left - c.left;
    startTop  = r.top  - c.top;

    document.onmousemove = (ev) => {
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      el.style.left = (startLeft + dx) + "px";
      el.style.top  = (startTop  + dy) + "px";
      gen();
    };

    document.onmouseup = () => document.onmousemove = null;
  };
}
Bu tek baÅŸÄ±na Ã§oÄŸu â€œtÄ±klayÄ±nca zÄ±plÄ±yorâ€ sorununu bitirir.

2) Input oninput=apply tÃ¼m alanlara baÄŸlÄ± ve â€œselâ€ deÄŸiÅŸince tetikleniyor
Åu satÄ±r:

["p_text","p_tx","p_font","p_w","p_h","p_bg","p_fg","p_len","p_dir","p_th","p_lc"]
.forEach(id=>document.getElementById(id).oninput=apply);
BazÄ± tarayÄ±cÄ±larda select / color inputâ€™lar programla value set edilince de input event ateÅŸleyebiliyor (her yerde deÄŸil ama oluyor). Sen loadProps() yapÄ±nca panel inputâ€™larÄ± set oluyor â†’ apply() tetikleniyor â†’ elementin width/height tekrar yazÄ±lÄ±yor â†’ bazen string/number dÃ¶nÃ¼ÅŸÃ¼mÃ¼nden â€œ1px kaymaâ€ bile boyut deÄŸiÅŸmiÅŸ gibi gÃ¶rÃ¼nÃ¼r.

âœ… Ã‡Ã¶zÃ¼m:
loadProps() sÄ±rasÄ±nda applyâ€™Ä± â€œkilitleâ€:

let loadingProps = false;

function loadProps(){
  if(!sel) return;
  loadingProps = true;

  // ... deÄŸerleri set et ...

  loadingProps = false;
}

function apply(){
  if(loadingProps) return;
  if(!sel) return;
  // ... normal apply ...
}
3) p_w.value / p_h.value boÅŸ kalÄ±rsa element â€œautoâ€ olur, sonra tÄ±klayÄ±nca geri yazÄ±lÄ±r
Input type number bazen boÅŸ kalÄ±rsa "" dÃ¶ndÃ¼rÃ¼r.
Sen:

sel.style.width = p_w.value + "px";
EÄŸer p_w.value=="" olursa "px" yazarsÄ±n â†’ browser bunu geÃ§ersiz sayar â†’ width â€œautoâ€ olur. Sonra tekrar tÄ±klayÄ±nca offsetWidth farklÄ± Ã§Ä±kar â†’ â€œboyut deÄŸiÅŸtiâ€ dersin.

âœ… Ã‡Ã¶zÃ¼m:
Number inputâ€™larÄ± daima sayÄ± olarak zorla:

const w = parseInt(p_w.value, 10);
if(!Number.isFinite(w)) return; // ya da default ver
sel.style.width = w + "px";
En hÄ±zlÄ± fix paketi (ben olsam bÃ¶yle yaparÄ±m)
drag()Ä± bounding-rect yÃ¶ntemiyle deÄŸiÅŸtir.

loadingProps kilidi ekle.

applyâ€™da width/height iÃ§in parseInt + guard yap.

Bunlar Ã§Ã¶zer.

Ä°stersen ben senin HTML dosyanÄ±n sadece deÄŸiÅŸmesi gereken kÄ±sÄ±mlarÄ±nÄ± (drag + loadProps/apply) â€œkopyala-yapÄ±ÅŸtÄ±râ€ hazÄ±r ÅŸekilde buraya bÄ±rakayÄ±m; sen direkt replace edersin.

You said:
tek parca olarak ver iyilestirdigin kodu deneyeyim
ChatGPT said:
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ESP32 TFT UI Designer</title>
</head>

<body style="margin:0">
<div style="display:flex;height:100vh;font-family:Arial;background:#222;color:#fff">

<!-- SOL PANEL -->
<div style="width:460px;padding:10px">

  <!-- ORIENTATION -->
  Orientation:
  <select id="orientation">
    <option value="landscape" selected>Landscape (320x240)</option>
    <option value="portrait">Portrait (240x320)</option>
  </select>
  <br><br>

  <!-- CANVAS -->
  <div id="canvas" style="
    width:320px;height:240px;
    background:#000;
    border:3px solid #555;
    position:relative;
    margin-bottom:10px"></div>

  Canvas BG:
  <input id="canvas_bg" type="color" value="#000000"><br><br>

  <button onclick="addLabel()">Add Label</button>
  <button onclick="addButton()">Add Button</button>
  <button onclick="addLine()">Add Line</button>
  <br><br>

  <button onclick="connectSerial()">ğŸ”Œ Connect ESP32</button>
  <button onclick="disconnectSerial()">âŒ Disconnect</button>
  <button onclick="sendSerial()">ğŸš€ Send to ESP32</button>

  <textarea id="code" style="width:100%;height:160px;margin-top:10px"></textarea>
</div>

<!-- PROPERTIES -->
<div style="flex:1;padding:10px">
  <h3>Properties</h3>

  <div id="uiProps">
    Text <input id="p_text"><br>
    TX <input id="p_tx"><br>
    Font
    <select id="p_font">
      <option value="0">FreeSans9pt</option>
      <option value="1" selected>FreeSans12pt</option>
      <option value="2">FreeSans18pt</option>
      <option value="3">FreeSansBold</option>
      <option value="4">FreeMonoOblique24pt</option>
      <option value="5">FreeSans24pt</option>
      <option value="6">FreeSansOblique12pt</option>
      <option value="7">FreeSerifBold24pt</option>
      <option value="8">TomThumb</option>
      <option value="9">Tiny3x3a2pt</option>
      <option value="10">Picopixel</option>
      <option value="11">Org_01</option>
    </select><br>
    Width <input id="p_w" type="number" min="1" step="1"><br>
    Height <input id="p_h" type="number" min="1" step="1"><br>
    BG <input id="p_bg" type="color"><br>
    FG <input id="p_fg" type="color"><br>
  </div>

  <div id="lineProps" style="display:none">
    Length <input id="p_len" type="number" min="1" step="1"><br>
    Direction
    <select id="p_dir">
      <option value="h">Horizontal</option>
      <option value="v">Vertical</option>
    </select><br>
    Thickness <input id="p_th" type="number" min="1" step="1"><br>
    Color <input id="p_lc" type="color"><br>
  </div>

  <br>
  <button onclick="del()">ğŸ—‘ Delete</button>

  <h3>Serial Monitor (RX)</h3>
  <textarea id="rx"
    style="width:100%;height:180px;
    background:#111;color:#0f0;
    font-family:monospace"></textarea>
</div>
</div>

<script>
/* ---------- STATE ---------- */
const canvas = document.getElementById("canvas");
const codeBox = document.getElementById("code");
const rxBox = document.getElementById("rx");
const canvasBgPicker = document.getElementById("canvas_bg");
const orientSel = document.getElementById("orientation");

const uiProps = document.getElementById("uiProps");
const lineProps = document.getElementById("lineProps");

const p_text = document.getElementById("p_text");
const p_tx   = document.getElementById("p_tx");
const p_font = document.getElementById("p_font");
const p_w    = document.getElementById("p_w");
const p_h    = document.getElementById("p_h");
const p_bg   = document.getElementById("p_bg");
const p_fg   = document.getElementById("p_fg");

const p_len  = document.getElementById("p_len");
const p_dir  = document.getElementById("p_dir");
const p_th   = document.getElementById("p_th");
const p_lc   = document.getElementById("p_lc");

let items = [], sel = null;
let loadingProps = false;

/* ---------- COLOR HELPERS (ALWAYS RETURN #RRGGBB) ---------- */
function toHex2(n){ return n.toString(16).padStart(2, "0"); }

function colorToHex(c){
  // Accepts: #RRGGBB, rgb(r,g,b), named colors
  const ctx = document.createElement("canvas").getContext("2d");
  ctx.fillStyle = "#000";
  ctx.fillStyle = c || "#000";
  const s = ctx.fillStyle;

  if (s.startsWith("#")) {
    if (s.length === 4) {
      // #rgb -> #rrggbb
      return "#" + s[1]+s[1] + s[2]+s[2] + s[3]+s[3];
    }
    return s.slice(0, 7);
  }

  // rgb(...) or rgba(...)
  const m = s.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
  if (m) {
    const r = Math.max(0, Math.min(255, parseInt(m[1],10)));
    const g = Math.max(0, Math.min(255, parseInt(m[2],10)));
    const b = Math.max(0, Math.min(255, parseInt(m[3],10)));
    return "#" + toHex2(r) + toHex2(g) + toHex2(b);
  }
  return "#000000";
}

function hexTo0x(hex){
  return "0x" + (hex || "#000000").replace("#","").toUpperCase();
}

/* ---------- ORIENTATION ---------- */
orientSel.onchange = ()=>{
  if(orientSel.value === "portrait"){
    canvas.style.width = "240px";
    canvas.style.height = "320px";
  }else{
    canvas.style.width = "320px";
    canvas.style.height = "240px";
  }
  gen();
};

/* ---------- SERIAL ---------- */
let port, writer, reader, keepReading = false;

/* ---------- DRAG (FIXED: NO offsetX/offsetY JITTER) ---------- */
function drag(el){
  let startX, startY, startLeft, startTop;

  el.onmousedown = (e) => {
    e.preventDefault();
    e.stopPropagation();

    sel = el;
    loadProps();

    const elRect = el.getBoundingClientRect();
    const cRect  = canvas.getBoundingClientRect();

    startX = e.clientX;
    startY = e.clientY;
    startLeft = elRect.left - cRect.left;
    startTop  = elRect.top  - cRect.top;

    document.onmousemove = (ev) => {
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      el.style.left = Math.round(startLeft + dx) + "px";
      el.style.top  = Math.round(startTop  + dy) + "px";
      gen();
    };

    document.onmouseup = () => {
      document.onmousemove = null;
      document.onmouseup = null;
    };
  };
}

/* ---------- ADD ---------- */
function baseEl(style){
  let e = document.createElement("div");
  e.style = style;
  e.style.position = "absolute";
  e.style.border = "2px dashed #aaa";
  e.style.boxSizing = "border-box"; // (stable sizing)
  drag(e);
  canvas.appendChild(e);
  items.push(e);
  return e;
}

function addLabel(){
  let e = baseEl(`
    left:10px;top:10px;width:160px;height:48px;
    background:black;color:white;
    display:flex;align-items:center;justify-content:center;
    border-radius:8px`);
  e.textContent = "LABEL";
  e.dataset.type = "label";
  e.dataset.font = "1";
  e.dataset.tx = "";
  sel = e; loadProps();
  gen();
}

function addButton(){
  let e = baseEl(`
    left:10px;top:70px;width:160px;height:48px;
    background:black;color:white;
    display:flex;align-items:center;justify-content:center;
    border-radius:8px`);
  e.textContent = "BUTTON";
  e.dataset.type = "button";
  e.dataset.font = "1";
  e.dataset.tx = "CMD";
  sel = e; loadProps();
  gen();
}

function addLine(){
  let e = baseEl(`
    left:20px;top:150px;width:100px;height:3px;
    background:yellow;border:none`);
  e.dataset.type = "line";
  e.dataset.dir = "h";
  sel = e; loadProps();
  gen();
}

/* ---------- PROPS ---------- */
function loadProps(){
  if(!sel) return;

  loadingProps = true;

  const type = sel.dataset.type;

  uiProps.style.display   = (type === "line") ? "none" : "block";
  lineProps.style.display = (type === "line") ? "block" : "none";

  if(type !== "line"){
    p_text.value = sel.textContent || "";
    p_tx.value   = sel.dataset.tx || "";
    p_font.value = sel.dataset.font || "1";
    p_w.value    = sel.getBoundingClientRect().width  | 0;
    p_h.value    = sel.getBoundingClientRect().height | 0;

    p_bg.value = colorToHex(sel.style.backgroundColor || "#000");
    p_fg.value = colorToHex(sel.style.color || "#fff");
  } else {
    const w = sel.getBoundingClientRect().width  | 0;
    const h = sel.getBoundingClientRect().height | 0;

    p_dir.value = sel.dataset.dir || "h";
    p_len.value = (p_dir.value === "h") ? w : h;
    p_th.value  = (p_dir.value === "h") ? h : w;
    p_lc.value  = colorToHex(sel.style.backgroundColor || "#FFFF00");
  }

  loadingProps = false;
}

function asInt(v, fallback){
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : fallback;
}

function apply(){
  if(loadingProps) return;
  if(!sel) return;

  const type = sel.dataset.type;

  if(type !== "line"){
    sel.textContent = p_text.value ?? "";
    sel.dataset.tx  = p_tx.value ?? "";
    sel.dataset.font = String(asInt(p_font.value, 1));

    const w = Math.max(1, asInt(p_w.value, sel.getBoundingClientRect().width  | 0));
    const h = Math.max(1, asInt(p_h.value, sel.getBoundingClientRect().height | 0));

    sel.style.width  = w + "px";
    sel.style.height = h + "px";

    sel.style.background = p_bg.value || "#000000";
    sel.style.color      = p_fg.value || "#FFFFFF";
  } else {
    const dir = p_dir.value || "h";
    sel.dataset.dir = dir;

    const len = Math.max(1, asInt(p_len.value, 100));
    const th  = Math.max(1, asInt(p_th.value, 3));

    if(dir === "h"){
      sel.style.width  = len + "px";
      sel.style.height = th  + "px";
    } else {
      sel.style.height = len + "px";
      sel.style.width  = th  + "px";
    }

    sel.style.background = p_lc.value || "#FFFF00";
  }

  gen();
}

["p_text","p_tx","p_font","p_w","p_h","p_bg","p_fg","p_len","p_dir","p_th","p_lc"]
  .forEach(id => document.getElementById(id).addEventListener("input", apply));

function del(){
  if(!sel) return;
  if(sel.parentElement === canvas) canvas.removeChild(sel);
  items = items.filter(i => i !== sel);
  sel = null;
  gen();
}

/* ---------- CANVAS BG ---------- */
canvasBgPicker.oninput = ()=>{
  canvas.style.backgroundColor = canvasBgPicker.value;
  gen();
};

/* ---------- CODE GEN (robust colors) ---------- */
function gen(){
  const bgHex = colorToHex(canvas.style.backgroundColor || "#000000");
  let out = [];

  out.push(orientSel.value === "portrait" ? "rotation(0)" : "rotation(1)");
  out.push(`clear(${hexTo0x(bgHex)})`);

  items.forEach(e=>{
    const x = asInt(e.style.left, 0);
    const y = asInt(e.style.top, 0);

    const rect = e.getBoundingClientRect();
    const w = rect.width  | 0;
    const h = rect.height | 0;

    const bgc = hexTo0x(colorToHex(e.style.backgroundColor || "#000000"));
    const fgc = hexTo0x(colorToHex(e.style.color || "#ffffff"));

    // NOTE: keeping your original protocol (no quotes).
    // If you want safer strings later, we can add quotes+escaping and update ESP32 parser.
    if(e.dataset.type === "label"){
      out.push(`label(${x},${y},${w},${h},${bgc},${fgc},${e.textContent},${asInt(e.dataset.font,1)})`);
    }

    if(e.dataset.type === "button"){
      out.push(`button(${x},${y},${w},${h},${bgc},${fgc},${e.textContent},${e.dataset.tx || ""},${asInt(e.dataset.font,1)})`);
    }

    if(e.dataset.type === "line"){
      const dir = e.dataset.dir || "h";
      if(dir === "h"){
        out.push(`line(${x},${y},${x+w},${y},${bgc},${h})`);
      }else{
        out.push(`line(${x},${y},${x},${y+h},${bgc},${w})`);
      }
    }
  });

  codeBox.value = out.join("\n");
}

/* ---------- WEB SERIAL ---------- */
async function connectSerial(){
  port = await navigator.serial.requestPort();
  await port.open({ baudRate:115200 });
  writer = port.writable.getWriter();
  reader = port.readable.getReader();
  keepReading = true;
  readLoop();
  alert("ESP32 Connected");
}

async function disconnectSerial(){
  keepReading = false;
  if(reader){ await reader.cancel(); reader.releaseLock(); }
  if(writer) writer.releaseLock();
  if(port) await port.close();
  alert("Disconnected");
}

async function readLoop(){
  const dec = new TextDecoder();
  let buf = "";
  while(keepReading){
    const {value,done} = await reader.read();
    if(done) break;
    buf += dec.decode(value);
    let lines = buf.split("\n");
    buf = lines.pop();
    lines.forEach(l=>{
      rxBox.value += l + "\n";
      rxBox.scrollTop = rxBox.scrollHeight;
    });
  }
}

async function sendSerial(){
  if(!writer) return alert("Not connected");
  const enc = new TextEncoder();
  for(let l of codeBox.value.split("\n")){
    await writer.write(enc.encode(l + "\n"));
    await new Promise(r=>setTimeout(r,40));
  }
}

/* ---------- INIT ---------- */
gen();
</script>
</body>
</html>
You said:
tamam calisiyor . Simdide biraz renk duzen kat programa cok amator duruyor hic renk yok bisey yok .   Serial Monitor (RX) paneli ve kod ciktisi aldigimiz panelin ekranin en altina koy uzun uzadiya dikkat et digerlerini kapamasin uzerlerine cikmasin 
ChatGPT said:
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ESP32 TFT UI Designer</title>
<style>
  :root{
    --bg0:#0b1020;
    --bg1:#0f1730;
    --bg2:#121c39;
    --card:#0f1a33cc;
    --card2:#0b1328cc;
    --stroke:#243257;
    --stroke2:#2e3c69;
    --text:#e7ecff;
    --muted:#aab4da;
    --accent:#7c5cff;
    --accent2:#25d8ff;
    --good:#31d0aa;
    --warn:#ffcc66;
    --danger:#ff5c7a;
    --shadow: 0 12px 40px rgba(0,0,0,.35);
    --radius:16px;
    --radius2:12px;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
    --dockH: 240px; /* bottom dock height */
  }

  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    font-family:var(--sans);
    color:var(--text);
    background:
      radial-gradient(1200px 800px at 20% -10%, rgba(124,92,255,.35), transparent 55%),
      radial-gradient(1000px 700px at 100% 10%, rgba(37,216,255,.22), transparent 55%),
      radial-gradient(900px 600px at 40% 120%, rgba(49,208,170,.14), transparent 55%),
      linear-gradient(180deg, var(--bg0), var(--bg1) 40%, var(--bg2));
    overflow:hidden;
  }

  /* App layout: top workspace + bottom dock */
  .app{
    height:100vh;
    display:flex;
    flex-direction:column;
    gap:12px;
    padding:14px;
  }

  .top{
    flex:1;
    min-height:0; /* important to allow internal scrolling */
    display:grid;
    grid-template-columns: 460px 1fr;
    gap:12px;
  }

  .panel{
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.08);
    border-color: rgba(36,50,87,.9);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    backdrop-filter: blur(8px);
    overflow:hidden;
    min-height:0;
  }

  .panel .hdr{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:12px 14px;
    border-bottom:1px solid rgba(255,255,255,.06);
    background: linear-gradient(180deg, rgba(255,255,255,.05), transparent);
  }

  .panel .hdr .title{
    display:flex;
    align-items:center;
    gap:10px;
    font-weight:700;
    letter-spacing:.2px;
  }

  .badge{
    font-size:12px;
    padding:4px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.10);
    color: var(--muted);
    background: rgba(0,0,0,.20);
  }

  .body{
    padding:12px 14px;
    overflow:auto;
    height:100%;
    min-height:0;
  }

  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .row + .row{ margin-top:10px; }

  label.small{
    font-size:12px;
    color:var(--muted);
    display:block;
    margin-bottom:6px;
  }

  .field{
    display:flex;
    flex-direction:column;
    gap:6px;
    min-width: 160px;
  }

  select, input[type="number"], input[type="text"]{
    width:100%;
    padding:10px 10px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    border-color: rgba(36,50,87,.95);
    background: rgba(0,0,0,.22);
    color: var(--text);
    outline:none;
  }
  input[type="color"]{
    width:46px;
    height:40px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.10);
    border-color: rgba(36,50,87,.95);
    background: rgba(0,0,0,.22);
    padding:4px;
  }

  select:focus, input:focus{
    border-color: rgba(124,92,255,.9);
    box-shadow: 0 0 0 3px rgba(124,92,255,.20);
  }

  .btns{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }

  .btn{
    cursor:pointer;
    user-select:none;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    border-color: rgba(46,60,105,.95);
    background: rgba(0,0,0,.22);
    color: var(--text);
    padding:10px 12px;
    font-weight:600;
    display:inline-flex;
    align-items:center;
    gap:8px;
    transition: transform .06s ease, background .15s ease, border-color .15s ease;
  }
  .btn:hover{
    background: rgba(255,255,255,.06);
    border-color: rgba(124,92,255,.55);
  }
  .btn:active{ transform: translateY(1px); }

  .btn.primary{
    background: linear-gradient(135deg, rgba(124,92,255,.25), rgba(37,216,255,.10));
    border-color: rgba(124,92,255,.65);
  }
  .btn.good{
    background: linear-gradient(135deg, rgba(49,208,170,.22), rgba(37,216,255,.08));
    border-color: rgba(49,208,170,.55);
  }
  .btn.danger{
    background: linear-gradient(135deg, rgba(255,92,122,.18), rgba(124,92,255,.10));
    border-color: rgba(255,92,122,.55);
  }
  .btn.ghost{
    background: rgba(0,0,0,.16);
  }

  .hint{
    margin-top:10px;
    font-size:12px;
    color: var(--muted);
    line-height:1.4;
  }

  /* Canvas area */
  .canvasWrap{
    display:flex;
    gap:12px;
    align-items:flex-start;
    flex-wrap:wrap;
  }

  #canvas{
    background:#000;
    border:2px solid rgba(255,255,255,.08);
    border-color: rgba(46,60,105,.95);
    border-radius: 18px;
    position:relative;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.04), 0 12px 30px rgba(0,0,0,.35);
    overflow:hidden;
  }

  /* Bottom dock (code + serial) */
  .dock{
    height: var(--dockH);
    min-height: 180px;
    max-height: 40vh;
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
  }
  .dock .panel{ min-height:0; }

  textarea{
    width:100%;
    height:100%;
    resize:none;
    padding:12px 12px;
    border-radius: 14px;
    border:1px solid rgba(255,255,255,.10);
    border-color: rgba(36,50,87,.95);
    background: rgba(0,0,0,.30);
    color: var(--text);
    outline:none;
    font-family: var(--mono);
    font-size: 12px;
    line-height: 1.35;
  }
  textarea:focus{
    border-color: rgba(37,216,255,.75);
    box-shadow: 0 0 0 3px rgba(37,216,255,.18);
  }

  .monoTag{
    font-family: var(--mono);
    font-size: 12px;
    color: rgba(231,236,255,.86);
  }

  /* Make the right panel scroll if needed without covering dock */
  .panel .body{ max-height: 100%; }
</style>
</head>

<body>
<div class="app">

  <!-- TOP WORKSPACE -->
  <div class="top">

    <!-- LEFT -->
    <div class="panel">
      <div class="hdr">
        <div class="title">ğŸ›ï¸ Designer <span class="badge">Drag & Drop</span></div>
        <div class="badge">ESP32 TFT</div>
      </div>

      <div class="body">
        <div class="row">
          <div class="field" style="min-width:260px;">
            <label class="small">Orientation</label>
            <select id="orientation">
              <option value="landscape" selected>Landscape (320x240)</option>
              <option value="portrait">Portrait (240x320)</option>
            </select>
          </div>

          <div class="field" style="min-width:140px;">
            <label class="small">Canvas BG</label>
            <input id="canvas_bg" type="color" value="#000000">
          </div>
        </div>

        <div class="row">
          <div class="canvasWrap">
            <div id="canvas" style="width:320px;height:240px;"></div>

            <div style="display:flex;flex-direction:column;gap:10px;min-width:160px;">
              <div class="btns">
                <button class="btn ghost" onclick="addLabel()">â• Label</button>
                <button class="btn ghost" onclick="addButton()">â• Button</button>
                <button class="btn ghost" onclick="addLine()">â• Line</button>
              </div>

              <div class="btns">
                <button class="btn good" onclick="connectSerial()">ğŸ”Œ Connect</button>
                <button class="btn danger" onclick="disconnectSerial()">âŒ Disconnect</button>
                <button class="btn primary" onclick="sendSerial()">ğŸš€ Send</button>
              </div>

              <div class="hint">
                ğŸ’¡ Ä°pucu: Element seÃ§mek iÃ§in tÄ±kla, sÃ¼rÃ¼klemek iÃ§in basÄ±lÄ± tutup taÅŸÄ±.<br>
                Alt paneldeki <span class="monoTag">CODE</span> ve <span class="monoTag">RX</span> alanlarÄ± sabit, hiÃ§bir zaman Ã¼stÃ¼ne binmez.
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>

    <!-- RIGHT -->
    <div class="panel">
      <div class="hdr">
        <div class="title">ğŸ§© Properties <span class="badge">Selected</span></div>
        <div class="badge">Live Update</div>
      </div>

      <div class="body">
        <div id="uiProps">
          <div class="row">
            <div class="field" style="min-width:260px;flex:1;">
              <label class="small">Text</label>
              <input id="p_text" type="text" placeholder="LABEL">
            </div>
            <div class="field" style="min-width:220px;flex:1;">
              <label class="small">TX</label>
              <input id="p_tx" type="text" placeholder="CMD">
            </div>
          </div>

          <div class="row">
            <div class="field" style="min-width:260px;flex:1;">
              <label class="small">Font</label>
              <select id="p_font">
                <option value="0">FreeSans9pt</option>
                <option value="1" selected>FreeSans12pt</option>
                <option value="2">FreeSans18pt</option>
                <option value="3">FreeSansBold</option>
                <option value="4">FreeMonoOblique24pt</option>
                <option value="5">FreeSans24pt</option>
                <option value="6">FreeSansOblique12pt</option>
                <option value="7">FreeSerifBold24pt</option>
                <option value="8">TomThumb</option>
                <option value="9">Tiny3x3a2pt</option>
                <option value="10">Picopixel</option>
                <option value="11">Org_01</option>
              </select>
            </div>
          </div>

          <div class="row">
            <div class="field">
              <label class="small">Width</label>
              <input id="p_w" type="number" min="1" step="1">
            </div>
            <div class="field">
              <label class="small">Height</label>
              <input id="p_h" type="number" min="1" step="1">
            </div>
            <div class="field">
              <label class="small">BG</label>
              <input id="p_bg" type="color" value="#000000">
            </div>
            <div class="field">
              <label class="small">FG</label>
              <input id="p_fg" type="color" value="#ffffff">
            </div>
          </div>
        </div>

        <div id="lineProps" style="display:none">
          <div class="row">
            <div class="field">
              <label class="small">Length</label>
              <input id="p_len" type="number" min="1" step="1">
            </div>
            <div class="field">
              <label class="small">Direction</label>
              <select id="p_dir">
                <option value="h">Horizontal</option>
                <option value="v">Vertical</option>
              </select>
            </div>
            <div class="field">
              <label class="small">Thickness</label>
              <input id="p_th" type="number" min="1" step="1">
            </div>
            <div class="field">
              <label class="small">Color</label>
              <input id="p_lc" type="color" value="#ffff00">
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:14px;">
          <button class="btn danger" onclick="del()">ğŸ—‘ Delete Selected</button>
        </div>

        <div class="hint">
          Not: Line elementleri rotation sonrasÄ± kaybolmasÄ±n istiyorsan ESP32 tarafÄ±nda lineâ€™larÄ± da element listesinde saklamak gerekir (istersen onu da ekleriz).
        </div>
      </div>
    </div>

  </div>

  <!-- BOTTOM DOCK: CODE + SERIAL RX -->
  <div class="dock">
    <div class="panel">
      <div class="hdr">
        <div class="title">ğŸ“„ Code Output <span class="badge">TX â†’ ESP32</span></div>
        <div class="badge monoTag">CODE</div>
      </div>
      <div class="body" style="padding:10px;">
        <textarea id="code" spellcheck="false"></textarea>
      </div>
    </div>

    <div class="panel">
      <div class="hdr">
        <div class="title">ğŸ–¥ï¸ Serial Monitor <span class="badge">RX</span></div>
        <div class="badge monoTag">RX</div>
      </div>
      <div class="body" style="padding:10px;">
        <textarea id="rx" spellcheck="false"></textarea>
      </div>
    </div>
  </div>

</div>

<script>
/* ---------- STATE ---------- */
const canvas = document.getElementById("canvas");
const codeBox = document.getElementById("code");
const rxBox = document.getElementById("rx");
const canvasBgPicker = document.getElementById("canvas_bg");
const orientSel = document.getElementById("orientation");

const uiProps = document.getElementById("uiProps");
const lineProps = document.getElementById("lineProps");

const p_text = document.getElementById("p_text");
const p_tx   = document.getElementById("p_tx");
const p_font = document.getElementById("p_font");
const p_w    = document.getElementById("p_w");
const p_h    = document.getElementById("p_h");
const p_bg   = document.getElementById("p_bg");
const p_fg   = document.getElementById("p_fg");

const p_len  = document.getElementById("p_len");
const p_dir  = document.getElementById("p_dir");
const p_th   = document.getElementById("p_th");
const p_lc   = document.getElementById("p_lc");

let items = [], sel = null;
let loadingProps = false;

/* ---------- COLOR HELPERS (ALWAYS RETURN #RRGGBB) ---------- */
function toHex2(n){ return n.toString(16).padStart(2, "0"); }
function colorToHex(c){
  const ctx = document.createElement("canvas").getContext("2d");
  ctx.fillStyle = "#000";
  ctx.fillStyle = c || "#000";
  const s = ctx.fillStyle;

  if (s.startsWith("#")) {
    if (s.length === 4) return "#" + s[1]+s[1] + s[2]+s[2] + s[3]+s[3];
    return s.slice(0, 7);
  }
  const m = s.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/i);
  if (m) {
    const r = Math.max(0, Math.min(255, parseInt(m[1],10)));
    const g = Math.max(0, Math.min(255, parseInt(m[2],10)));
    const b = Math.max(0, Math.min(255, parseInt(m[3],10)));
    return "#" + toHex2(r) + toHex2(g) + toHex2(b);
  }
  return "#000000";
}
function hexTo0x(hex){
  return "0x" + (hex || "#000000").replace("#","").toUpperCase();
}

/* ---------- ORIENTATION ---------- */
orientSel.onchange = ()=>{
  if(orientSel.value === "portrait"){
    canvas.style.width = "240px";
    canvas.style.height = "320px";
  }else{
    canvas.style.width = "320px";
    canvas.style.height = "240px";
  }
  gen();
};

/* ---------- SERIAL ---------- */
let port, writer, reader, keepReading = false;

/* ---------- DRAG (STABLE) ---------- */
function drag(el){
  let startX, startY, startLeft, startTop;

  el.onmousedown = (e) => {
    e.preventDefault();
    e.stopPropagation();

    sel = el;
    loadProps();

    const elRect = el.getBoundingClientRect();
    const cRect  = canvas.getBoundingClientRect();

    startX = e.clientX;
    startY = e.clientY;
    startLeft = elRect.left - cRect.left;
    startTop  = elRect.top  - cRect.top;

    document.onmousemove = (ev) => {
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      el.style.left = Math.round(startLeft + dx) + "px";
      el.style.top  = Math.round(startTop  + dy) + "px";
      gen();
    };

    document.onmouseup = () => {
      document.onmousemove = null;
      document.onmouseup = null;
    };
  };
}

/* ---------- ADD ---------- */
function baseEl(style){
  let e = document.createElement("div");
  e.style = style;
  e.style.position = "absolute";
  e.style.border = "2px dashed rgba(231,236,255,.55)";
  e.style.boxSizing = "border-box";
  e.style.backdropFilter = "blur(4px)";
  e.style.boxShadow = "0 10px 22px rgba(0,0,0,.25)";
  drag(e);
  canvas.appendChild(e);
  items.push(e);
  return e;
}

function addLabel(){
  let e = baseEl(`
    left:10px;top:10px;width:160px;height:48px;
    background:rgba(0,0,0,.35);color:white;
    display:flex;align-items:center;justify-content:center;
    border-radius:14px`);
  e.textContent = "LABEL";
  e.dataset.type = "label";
  e.dataset.font = "1";
  e.dataset.tx = "";
  sel = e; loadProps();
  gen();
}

function addButton(){
  let e = baseEl(`
    left:10px;top:70px;width:160px;height:48px;
    background:rgba(124,92,255,.22);color:white;
    display:flex;align-items:center;justify-content:center;
    border-radius:16px`);
  e.textContent = "BUTTON";
  e.dataset.type = "button";
  e.dataset.font = "1";
  e.dataset.tx = "CMD";
  sel = e; loadProps();
  gen();
}

function addLine(){
  let e = baseEl(`
    left:20px;top:150px;width:100px;height:3px;
    background:#FFFF00;border:none;border-radius:99px`);
  e.dataset.type = "line";
  e.dataset.dir = "h";
  // line shouldn't have dashed border
  e.style.border = "none";
  sel = e; loadProps();
  gen();
}

/* ---------- PROPS ---------- */
function asInt(v, fallback){
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : fallback;
}

function loadProps(){
  if(!sel) return;

  loadingProps = true;

  const type = sel.dataset.type;
  uiProps.style.display   = (type === "line") ? "none" : "block";
  lineProps.style.display = (type === "line") ? "block" : "none";

  if(type !== "line"){
    p_text.value = sel.textContent || "";
    p_tx.value   = sel.dataset.tx || "";
    p_font.value = sel.dataset.font || "1";

    const r = sel.getBoundingClientRect();
    p_w.value = r.width  | 0;
    p_h.value = r.height | 0;

    p_bg.value = colorToHex(sel.style.backgroundColor || "#000");
    p_fg.value = colorToHex(sel.style.color || "#fff");
  } else {
    const r = sel.getBoundingClientRect();
    const w = r.width  | 0;
    const h = r.height | 0;

    p_dir.value = sel.dataset.dir || "h";
    p_len.value = (p_dir.value === "h") ? w : h;
    p_th.value  = (p_dir.value === "h") ? h : w;
    p_lc.value  = colorToHex(sel.style.backgroundColor || "#FFFF00");
  }

  loadingProps = false;
}

function apply(){
  if(loadingProps) return;
  if(!sel) return;

  const type = sel.dataset.type;

  if(type !== "line"){
    sel.textContent = p_text.value ?? "";
    sel.dataset.tx  = p_tx.value ?? "";
    sel.dataset.font = String(asInt(p_font.value, 1));

    const w = Math.max(1, asInt(p_w.value, sel.getBoundingClientRect().width  | 0));
    const h = Math.max(1, asInt(p_h.value, sel.getBoundingClientRect().height | 0));
    sel.style.width  = w + "px";
    sel.style.height = h + "px";

    sel.style.background = p_bg.value || "#000000";
    sel.style.color      = p_fg.value || "#FFFFFF";
  } else {
    const dir = p_dir.value || "h";
    sel.dataset.dir = dir;

    const len = Math.max(1, asInt(p_len.value, 100));
    const th  = Math.max(1, asInt(p_th.value, 3));

    if(dir === "h"){
      sel.style.width  = len + "px";
      sel.style.height = th  + "px";
    } else {
      sel.style.height = len + "px";
      sel.style.width  = th  + "px";
    }

    sel.style.background = p_lc.value || "#FFFF00";
  }

  gen();
}

["p_text","p_tx","p_font","p_w","p_h","p_bg","p_fg","p_len","p_dir","p_th","p_lc"]
  .forEach(id => document.getElementById(id).addEventListener("input", apply));

function del(){
  if(!sel) return;
  if(sel.parentElement === canvas) canvas.removeChild(sel);
  items = items.filter(i => i !== sel);
  sel = null;
  gen();
}

/* ---------- CANVAS BG ---------- */
canvasBgPicker.oninput = ()=>{
  canvas.style.backgroundColor = canvasBgPicker.value;
  gen();
};

/* ---------- CODE GEN ---------- */
function gen(){
  const bgHex = colorToHex(canvas.style.backgroundColor || "#000000");
  let out = [];

  out.push(orientSel.value === "portrait" ? "rotation(0)" : "rotation(1)");
  out.push(`clear(${hexTo0x(bgHex)})`);

  items.forEach(e=>{
    const x = asInt(e.style.left, 0);
    const y = asInt(e.style.top, 0);

    const rect = e.getBoundingClientRect();
    const w = rect.width  | 0;
    const h = rect.height | 0;

    const bgc = hexTo0x(colorToHex(e.style.backgroundColor || "#000000"));
    const fgc = hexTo0x(colorToHex(e.style.color || "#ffffff"));

    if(e.dataset.type === "label"){
      out.push(`label(${x},${y},${w},${h},${bgc},${fgc},${e.textContent},${asInt(e.dataset.font,1)})`);
    }

    if(e.dataset.type === "button"){
      out.push(`button(${x},${y},${w},${h},${bgc},${fgc},${e.textContent},${e.dataset.tx || ""},${asInt(e.dataset.font,1)})`);
    }

    if(e.dataset.type === "line"){
      const dir = e.dataset.dir || "h";
      if(dir === "h"){
        out.push(`line(${x},${y},${x+w},${y},${bgc},${h})`);
      }else{
        out.push(`line(${x},${y},${x},${y+h},${bgc},${w})`);
      }
    }
  });

  codeBox.value = out.join("\n");
}

/* ---------- WEB SERIAL ---------- */
async function connectSerial(){
  port = await navigator.serial.requestPort();
  await port.open({ baudRate:115200 });
  writer = port.writable.getWriter();
  reader = port.readable.getReader();
  keepReading = true;
  readLoop();
  alert("ESP32 Connected");
}

async function disconnectSerial(){
  keepReading = false;
  if(reader){ await reader.cancel(); reader.releaseLock(); }
  if(writer) writer.releaseLock();
  if(port) await port.close();
  alert("Disconnected");
}

async function readLoop(){
  const dec = new TextDecoder();
  let buf = "";
  while(keepReading){
    const {value,done} = await reader.read();
    if(done) break;
    buf += dec.decode(value);
    let lines = buf.split("\n");
    buf = lines.pop();
    lines.forEach(l=>{
      rxBox.value += l + "\n";
      rxBox.scrollTop = rxBox.scrollHeight;
    });
  }
}

async function sendSerial(){
  if(!writer) return alert("Not connected");
  const enc = new TextEncoder();
  for(let l of codeBox.value.split("\n")){
    await writer.write(enc.encode(l + "\n"));
    await new Promise(r=>setTimeout(r,40));
  }
}

/* ---------- INIT ---------- */
gen();
</script>
</body>
</html>


No file chosenNo file chosen
ChatGPT can make mistakes. Check important info. See Cookie Preferences.
