<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ESP32 TFT UI Designer</title>
</head>

<body style="margin:0">
<div style="display:flex;height:100vh;font-family:Arial;background:#222;color:#fff">

<!-- SOL PANEL -->
<div style="width:460px;padding:10px">

  <!-- ORIENTATION -->
  Orientation:
  <select id="orientation">
    <option value="landscape" selected>Landscape (320x240)</option>
    <option value="portrait">Portrait (240x320)</option>
  </select>
  <br><br>

  <!-- CANVAS -->
  <div id="canvas" style="
    width:320px;height:240px;
    background:#000;
    border:3px solid #555;
    position:relative;
    margin-bottom:10px"></div>

  Canvas BG:
  <input id="canvas_bg" type="color" value="#000000"><br><br>

  <button onclick="addLabel()">Add Label</button>
  <button onclick="addButton()">Add Button</button>
  <button onclick="addLine()">Add Line</button>
  <br><br>

  <button onclick="connectSerial()">ğŸ”Œ Connect ESP32</button>
  <button onclick="disconnectSerial()">âŒ Disconnect</button>
  <button onclick="sendSerial()">ğŸš€ Send to ESP32</button>

  <textarea id="code" style="width:100%;height:160px;margin-top:10px"></textarea>
</div>

<!-- PROPERTIES -->
<div style="flex:1;padding:10px">
  <h3>Properties</h3>

  <div id="uiProps">
    Text <input id="p_text"><br>
    TX <input id="p_tx"><br>
    Font
    <select id="p_font">
      <option value="0">FreeSans9pt</option>
      <option value="1" selected>FreeSans12pt</option>
      <option value="2">FreeSans18pt</option>
      <option value="3">FreeSansBold</option>
      <option value="4">FreeMonoOblique24pt</option>
      <option value="5">FreeSans24pt</option>
      <option value="6">FreeSansOblique12pt</option>
      <option value="7">FreeSerifBold24pt</option>
      <option value="8">TomThumb</option>
      <option value="9">Tiny3x3a2pt</option>
      <option value="10">Picopixel</option>
      <option value="11">Org_01</option>
    </select><br>
    Width <input id="p_w" type="number"><br>
    Height <input id="p_h" type="number"><br>
    BG <input id="p_bg" type="color"><br>
    FG <input id="p_fg" type="color"><br>
  </div>

  <div id="lineProps" style="display:none">
    Length <input id="p_len" type="number"><br>
    Direction
    <select id="p_dir">
      <option value="h">Horizontal</option>
      <option value="v">Vertical</option>
    </select><br>
    Thickness <input id="p_th" type="number"><br>
    Color <input id="p_lc" type="color"><br>
  </div>

  <br>
  <button onclick="del()">ğŸ—‘ Delete</button>

  <h3>Serial Monitor (RX)</h3>
  <textarea id="rx"
    style="width:100%;height:180px;
    background:#111;color:#0f0;
    font-family:monospace"></textarea>
</div>
</div>

<script>
/* ---------- STATE ---------- */
const canvas = document.getElementById("canvas");
const codeBox = document.getElementById("code");
const rxBox = document.getElementById("rx");
const canvasBgPicker = document.getElementById("canvas_bg");
const orientSel = document.getElementById("orientation");
let items=[], sel=null;

/* ---------- ORIENTATION ---------- */
orientSel.onchange = ()=>{
  if(orientSel.value=="portrait"){
    canvas.style.width="240px";
    canvas.style.height="320px";
  }else{
    canvas.style.width="320px";
    canvas.style.height="240px";
  }
  gen();
}

/* ---------- SERIAL ---------- */
let port, writer, reader, keepReading=false;

/* ---------- HELPERS ---------- */
function rgb(c){
  let ctx=document.createElement("canvas").getContext("2d");
  ctx.fillStyle=c; return ctx.fillStyle;
}

/* ---------- DRAG ---------- */
function drag(el){
  let ox,oy;
  el.onmousedown=e=>{
    sel=el; loadProps();
    ox=e.offsetX; oy=e.offsetY;
    document.onmousemove=ev=>{
      el.style.left=ev.pageX-canvas.offsetLeft-ox+"px";
      el.style.top =ev.pageY-canvas.offsetTop -oy+"px";
      gen();
    }
    document.onmouseup=()=>document.onmousemove=null;
  }
}

/* ---------- ADD ---------- */
function baseEl(style){
  let e=document.createElement("div");
  e.style=style;
  e.style.position="absolute";
  e.style.border="2px dashed #aaa";
  drag(e);
  canvas.appendChild(e);
  items.push(e);
  return e;
}

function addLabel(){
  let e=baseEl(`
    left:10px;top:10px;width:160px;height:48px;
    background:black;color:white;
    display:flex;align-items:center;justify-content:center;
    border-radius:8px`);
  e.textContent="LABEL";
  e.dataset.type="label";
  e.dataset.font=1;
  e.dataset.tx="";
  gen();
}

function addButton(){
  let e=baseEl(`
    left:10px;top:70px;width:160px;height:48px;
    background:black;color:white;
    display:flex;align-items:center;justify-content:center;
    border-radius:8px`);
  e.textContent="BUTTON";
  e.dataset.type="button";
  e.dataset.font=1;
  e.dataset.tx="CMD";
  gen();
}

function addLine(){
  let e=baseEl(`
    left:20px;top:150px;width:100px;height:3px;
    background:yellow;border:none`);
  e.dataset.type="line";
  e.dataset.dir="h";
  gen();
}

/* ---------- PROPS ---------- */
function loadProps(){
  if(!sel) return;
  uiProps.style.display=sel.dataset.type=="line"?"none":"block";
  lineProps.style.display=sel.dataset.type=="line"?"block":"none";

  if(sel.dataset.type!="line"){
    p_text.value=sel.textContent;
    p_tx.value=sel.dataset.tx;
    p_font.value=sel.dataset.font;
    p_w.value=sel.offsetWidth;
    p_h.value=sel.offsetHeight;
    p_bg.value=rgb(sel.style.backgroundColor);
    p_fg.value=rgb(sel.style.color);
  }else{
    p_len.value=sel.dataset.dir=="h"?sel.offsetWidth:sel.offsetHeight;
    p_th.value=sel.dataset.dir=="h"?sel.offsetHeight:sel.offsetWidth;
    p_dir.value=sel.dataset.dir;
    p_lc.value=rgb(sel.style.backgroundColor);
  }
}

function apply(){
  if(!sel) return;
  if(sel.dataset.type!="line"){
    sel.textContent=p_text.value;
    sel.dataset.tx=p_tx.value;
    sel.dataset.font=p_font.value;
    sel.style.width=p_w.value+"px";
    sel.style.height=p_h.value+"px";
    sel.style.background=p_bg.value;
    sel.style.color=p_fg.value;
  }else{
    sel.dataset.dir=p_dir.value;
    if(p_dir.value=="h"){
      sel.style.width=p_len.value+"px";
      sel.style.height=p_th.value+"px";
    }else{
      sel.style.height=p_len.value+"px";
      sel.style.width=p_th.value+"px";
    }
    sel.style.background=p_lc.value;
  }
  gen();
}

["p_text","p_tx","p_font","p_w","p_h","p_bg","p_fg","p_len","p_dir","p_th","p_lc"]
.forEach(id=>document.getElementById(id).oninput=apply);

function del(){
  if(!sel) return;
  canvas.removeChild(sel);
  items=items.filter(i=>i!=sel);
  sel=null;
  gen();
}

/* ---------- CANVAS BG ---------- */
canvasBgPicker.oninput=()=>{
  canvas.style.backgroundColor=canvasBgPicker.value;
  gen();
}

/* ---------- CODE GEN ---------- */
function gen(){
  let bg=rgb(canvas.style.backgroundColor).slice(1).toUpperCase();
  let out=[];

  out.push(
    orientSel.value=="portrait" ? "rotation(0)" : "rotation(1)"
  );

  out.push(`clear(0x${bg})`);

  items.forEach(e=>{
    let x=parseInt(e.style.left),
        y=parseInt(e.style.top),
        w=e.offsetWidth,
        h=e.offsetHeight;

    let bgc=rgb(e.style.backgroundColor).slice(1).toUpperCase();
    let fgc=rgb(e.style.color||"#fff").slice(1).toUpperCase();

    if(e.dataset.type=="label")
      out.push(`label(${x},${y},${w},${h},0x${bgc},0x${fgc},${e.textContent},${e.dataset.font})`);

    if(e.dataset.type=="button")
      out.push(`button(${x},${y},${w},${h},0x${bgc},0x${fgc},${e.textContent},${e.dataset.tx},${e.dataset.font})`);

    if(e.dataset.type=="line"){
      if(e.dataset.dir=="h")
        out.push(`line(${x},${y},${x+w},${y},0x${bgc},${h})`);
      else
        out.push(`line(${x},${y},${x},${y+h},0x${bgc},${w})`);
    }
  });

  codeBox.value=out.join("\n");
}

/* ---------- WEB SERIAL ---------- */
async function connectSerial(){
  port=await navigator.serial.requestPort();
  await port.open({ baudRate:115200 });
  writer=port.writable.getWriter();
  reader=port.readable.getReader();
  keepReading=true;
  readLoop();
  alert("ESP32 Connected");
}

async function disconnectSerial(){
  keepReading=false;
  if(reader){ await reader.cancel(); reader.releaseLock(); }
  if(writer) writer.releaseLock();
  if(port) await port.close();
  alert("Disconnected");
}

async function readLoop(){
  const dec=new TextDecoder();
  let buf="";
  while(keepReading){
    const {value,done}=await reader.read();
    if(done) break;
    buf+=dec.decode(value);
    let lines=buf.split("\n");
    buf=lines.pop();
    lines.forEach(l=>{
      rxBox.value+=l+"\n";
      rxBox.scrollTop=rxBox.scrollHeight;
    });
  }
}

async function sendSerial(){
  if(!writer) return alert("Not connected");
  const enc=new TextEncoder();
  for(let l of codeBox.value.split("\n")){
    await writer.write(enc.encode(l+"\n"));
    await new Promise(r=>setTimeout(r,40));
  }
}
</script>
</body>
</html>
